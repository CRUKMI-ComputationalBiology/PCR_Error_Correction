
#include "IRKE.hpp"
#include "KmerCounter.hpp"
#include "stacktrace.hpp"

#include "typedefs.h"
#include "mrSubroutine.h"


using namespace MAPREDUCE_NS;
using namespace std;


void fileread_RNAseq_HeadSeq_FASTA(int itask, char *fname, KeyValue *kv, void *ptr)
{
  Data *data = (Data *) ptr;
  RankID rankid;
  struct stat stbuf;
  int flag = stat(fname,&stbuf);
  if (flag < 0) {
    printf("ERROR: Could not query file size\n");
    MPI_Abort(MPI_COMM_WORLD,1);
  }

  string filename(fname);
  std::size_t fpos = filename.find("sKmer_");
  if( fpos != std::string::npos ) {

    Fasta_reader fasta_reader(filename);
    while (true) {
        Fasta_entry fe = fasta_reader.getNext();
        string seq    = fe.get_sequence();
        string header = fe.get_header();
        if (seq == "") break;

        std::size_t pos = header.find_first_of(" ");
        if(pos != std::string::npos) header.replace(pos,1,"_");

        char *HeadSeq = (char *) malloc(sizeof(char)*(seq.length() + header.length()+1));
        memcpy(HeadSeq, header.substr(0,header.length()).c_str(), header.length());
        HeadSeq[header.length()] = ' ';
        for(int i=0; i<seq.length(); i++) HeadSeq[header.length()+1+i] = seq.at(i);

	std::size_t hpos = header.find_first_of("_");
        kv->add((char *) header.substr(0,hpos).c_str(), sizeof(char)*hpos, (char *) HeadSeq, sizeof(char)*(seq.length() + header.length()+1) );

        free(HeadSeq);
	data->range = (int)seq.length();	
    }

  }
}

void fileread_RNAseq_HeadSeq_FASTQ(int itask, char *fname, KeyValue *kv, void *ptr)
{
  Data *data = (Data *) ptr;
  RankID rankid;
  struct stat stbuf;
  int flag = stat(fname,&stbuf);
  if (flag < 0) {
    printf("ERROR: Could not query file size\n");
    MPI_Abort(MPI_COMM_WORLD,1);
  }

  string filename(fname);
  std::size_t fpos = filename.find("sKmer_");
  if( fpos != std::string::npos ) {

     FastQFile fastQFile; 
     if(fastQFile.openFile(filename.c_str()) != FastQStatus::FASTQ_SUCCESS)
     {
       printf("ERROR: Failed to open file: %s \n", filename.c_str());
       MPI_Abort(MPI_COMM_WORLD,1); 
     }

     while (fastQFile.keepReadingFile())
     {
	if(fastQFile.readFastQSequence() == FastQStatus::FASTQ_SUCCESS)
        {
	  string header, seq, quality;
	  header.assign(fastQFile.mySequenceIdLine); 
	  seq.assign(fastQFile.myRawSequence);
	  quality.assign(fastQFile.myQualityString);

	  seq.assign( seq.substr(0,seq.length()).c_str(),         seq.length() );
	  quality.assign( quality.substr(0,seq.length()).c_str(), seq.length() );

	  std::size_t pos = header.find_first_of(" ");
          if(pos != std::string::npos) header.replace(pos,1,"_");

          char *HeadSeq = (char *) malloc(sizeof(char)*(header.length() + seq.length() + seq.length() + 1));
          memcpy(HeadSeq, header.substr(1,header.length()-1).c_str(), header.length()-1);
          HeadSeq[header.length()-1] = ' ';
          for(int i=0; i<seq.length(); i++) HeadSeq[header.length()+i] = seq.at(i);

   	  int PE_direction = 0;
          std::size_t pe_pos = header.find_first_of("_");

          if( header.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
          if( header.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

          HeadSeq[header.length()+seq.length()] = ' ';
	  for(int i=0; i<seq.length(); i++) {
		HeadSeq[header.length() + seq.length() + 1 + i] = quality.at(i);

	//	int Q = get_Qscore(quality.c_str()[i]);
	//	if(PE_direction == 1) data->QV_error[  Q ]++;
	//	else		      data->QV_nerror[ Q ]++;
	  }

          std::size_t hpos = header.find_first_of("_");
//          kv->add((char *) header.substr(1,hpos-1).c_str(), sizeof(char)*(hpos-1), (char *) HeadSeq, sizeof(char)*(seq.length() + header.length() + quality.length() + 1) );
	  kv->add((char *) header.substr(1,header.length()-1).c_str(), sizeof(char)*(header.length()-1), (char *) HeadSeq, sizeof(char)*(header.length() + seq.length() + seq.length() + 1) );

          free(HeadSeq);
          data->range = (int)seq.length();
	}
     }

     fastQFile.closeFile();
  }   

}



void fileread_AlignmentInfo(int itask, char *fname, KeyValue *kv, void *ptr)
{
  Data *data = (Data *) ptr;
  struct stat stbuf;
  int flag = stat(fname,&stbuf);
  if (flag < 0) {
    printf("ERROR: Could not query file size\n");
    MPI_Abort(MPI_COMM_WORLD,1);
  }

  std::string filename(fname);
  std::size_t fpos = filename.find("bfiltered_");

  if( fpos != std::string::npos ) {
    FILE* FS;
    FS = fopen(filename.c_str(), "r");

    int num = 0;

    while (!feof(FS)) {
        char temp_string[500];
        char head[100];
        char cigar[300];
        char dummy[10];
        int maq;
        int misc;

        sReadInfo read;

        fgets(temp_string, 500, FS);

        int n = sscanf(temp_string, "%s %s %d %d %s %d", dummy, head, &read.loc, &maq, cigar, &misc);
        if(n < 5) break;

        string name(head);
        name = remove_whitespace(name);

        if(      strcmp(dummy, "1") == 0) read.chr = 1;
        else if( strcmp(dummy, "2") == 0) read.chr = 2;
        else if( strcmp(dummy, "3") == 0) read.chr = 3;
        else if( strcmp(dummy, "4") == 0) read.chr = 4;
        else if( strcmp(dummy, "5") == 0) read.chr = 5;
        else if( strcmp(dummy, "6") == 0) read.chr = 6;
        else if( strcmp(dummy, "7") == 0) read.chr = 7;
        else if( strcmp(dummy, "8") == 0) read.chr = 8;
        else if( strcmp(dummy, "9") == 0) read.chr = 9;
        else if( strcmp(dummy,"10") == 0) read.chr = 10;
        else if( strcmp(dummy,"11") == 0) read.chr = 11;
        else if( strcmp(dummy,"12") == 0) read.chr = 12;
        else if( strcmp(dummy,"13") == 0) read.chr = 13;
        else if( strcmp(dummy,"14") == 0) read.chr = 14;
        else if( strcmp(dummy,"15") == 0) read.chr = 15;
        else if( strcmp(dummy,"16") == 0) read.chr = 16;
        else if( strcmp(dummy,"17") == 0) read.chr = 17;
        else if( strcmp(dummy,"18") == 0) read.chr = 18;
        else if( strcmp(dummy,"19") == 0) read.chr = 19;
        else if( strcmp(dummy,"20") == 0) read.chr = 20;
        else if( strcmp(dummy,"21") == 0) read.chr = 21;
        else if( strcmp(dummy,"22") == 0) read.chr = 22;
        else if( strcmp(dummy, "X") == 0) read.chr = 23;
        else if( strcmp(dummy, "Y") == 0) read.chr = 24;
//        else if( strcmp(dummy,"MT") == 0) read.chr = 25;

     if( (read.chr>=1) && (read.chr<=24) ) {
//	if(read.chr == 1) {
	std::size_t pos = name.find_first_of("_");

	read.pe = atoi( name.substr(pos+1,1).c_str() );

	read.strand = read.pe;
	
//        if(misc > 0)      read.strand = 1;
//        else if(misc < 0) read.strand = -1;
//        else              read.strand = 0;

//        bool onTarget = false;
//  	for(int i=0; i<data->_target_loc.size(); i++) {
//    	      ExonLoc _locInfo = data->_target_loc.at(i);
//	      if( read.chr == _locInfo.chr ) {
//		 if( ( read.loc >= (_locInfo.loc1 - data->flank)) && (read.loc <= (_locInfo.loc2 + data->flank)) ) 
//		  {
//			onTarget = true;
//			break;
//		  }

//                 if( ((read.loc+data->range-1) >= (_locInfo.loc1 - data->flank)) && ((read.loc+data->range-1) <= (_locInfo.loc2 + data->flank)) )
//                  {
//                        onTarget = true;
//                        break;
//                  }

//	      }
//  	}

	bool onClipping = false;
	int num_clip = parse_cigar_softclipping(cigar);
	if((num_clip <= 2) && (num_clip >=0) ) onClipping = true;

	if( onClipping && (maq >= data->MAQ)) kv->add((char *) name.substr(0,name.length()).c_str(), sizeof(char) * name.length(), (char *) &read, sizeof(sReadInfo) );

//	if(data->filter_offTarget && data->filter_clipping) {
//	  if( onTarget && onClipping ) 
//		kv->add((char *) name.substr(0,pos).c_str(), sizeof(char) * pos, (char *) &read, sizeof(sReadInfo) );
//	} else if(data->filter_offTarget && onTarget) {
//                kv->add((char *) name.substr(0,pos).c_str(), sizeof(char) * pos, (char *) &read, sizeof(sReadInfo) );
//        } else if(data->filter_clipping && onClipping) {
//                kv->add((char *) name.substr(0,pos).c_str(), sizeof(char) * pos, (char *) &read, sizeof(sReadInfo) );
//        } else if(!data->filter_offTarget && !data->filter_clipping) {
//		kv->add((char *) name.substr(0,pos).c_str(), sizeof(char) * pos, (char *) &read, sizeof(sReadInfo) );
//	}


     }
   }
  }

}

int parse_cigar_softclipping(char *s)
{
   int num_soft = 0;
   char* p=(char*)(s);
   while(*p!=0)
   {
	 char* endptr;

         if(!isdigit(*p)) return -1;
         int c_size =strtol(p,&endptr,10);
         if(c_size<=0)    return -1;
         p=endptr;

	 int check = 0;
         if(!isalpha(*p)) return -1;
 
         if((p[0] == 'S') || (p[0] == 'H')) check++;
	 if(check>0)    num_soft += c_size; 
         ++p;
   }
   return num_soft;
}

void reduce_AlignLoc(char *key, int keybytes, char *multivalue, int nvalues, int *valuebytes, KeyValue *kv, void *ptr)
{
  if(nvalues == 2 ) {

    string KHS;
    KHS.assign(key, keybytes);

    char *value;
    sReadInfo *locInfo;
    string header_seq;
    int flag_loc = 0;
    int flag_hs  = 0;

    int header_length;

    uint64_t nvalues_total;
    CHECK_FOR_BLOCKS(multivalue,valuebytes,nvalues,nvalues_total)
    BEGIN_BLOCK_LOOP(multivalue,valuebytes,nvalues)

      value = multivalue;
      if(valuebytes[0] == sizeof(sReadInfo)) {
	locInfo = (sReadInfo *) value;
	flag_loc += 1;
      } else {
	header_seq.assign(value, valuebytes[0]);
	header_length = valuebytes[0];
        std::size_t pos = header_seq.find_first_of(" ");
        if((pos != std::string::npos) && (KHS.compare(header_seq.substr(0,pos)) == 0) ) flag_hs += 1;
      }

      value += valuebytes[0];

      if(valuebytes[1] == sizeof(sReadInfo)) {
        locInfo = (sReadInfo *) value;
        flag_loc += 1;
      } else {
        header_seq.assign(value, valuebytes[1]);
	header_length = valuebytes[1];
	std::size_t pos = header_seq.find_first_of(" ");
        if((pos != std::string::npos) && (KHS.compare(header_seq.substr(0,pos)) == 0) ) flag_hs += 1;
      }
 
    END_BLOCK_LOOP

    if((flag_loc == 1) && (flag_hs == 1)) {
	AlignInfo alignInfo;
	alignInfo.chr = locInfo->chr;
        alignInfo.loc = locInfo->loc; 	
	kv->add((char *) &alignInfo, sizeof(AlignInfo), (char *) header_seq.substr(0,header_length).c_str(), sizeof(char)*header_length );
    }

  }
}

void reduce_print_Group_Aligned(char *key, int keybytes, char *multivalue, int nvalues, int *valuebytes, KeyValue *kv, void *ptr)
{
    Data *data = (Data *) ptr;
    AlignInfo *alignInfo = (AlignInfo *) key;
    data->outFile << alignInfo->chr << "\t" << alignInfo->loc << "\t" << nvalues << endl;
}


void reduce_Link_from_Header(char *key, int keybytes, char *multivalue, int nvalues, int *valuebytes, KeyValue *kv, void *ptr)
{
  if(nvalues == 2 ) {
    Data *data = (Data *) ptr;
    char *value;

    uint64_t nvalues_total;
    CHECK_FOR_BLOCKS(multivalue,valuebytes,nvalues,nvalues_total)
    BEGIN_BLOCK_LOOP(multivalue,valuebytes,nvalues)

      value = multivalue;
      sReadInfo *link1 = (sReadInfo *) value;

      value += valuebytes[0];
      sReadInfo *link2 = (sReadInfo *) value;

      PairLink pair;

      if(link1->loc <= link2->loc) {
            pair.chr1 = link1->chr;
            pair.chr2 = link2->chr;

            pair.pe1 = link1->pe;
            pair.pe2 = link2->pe;

            pair.loc1 = link1->loc;
            pair.loc2 = link2->loc;

            pair.strand1 = 1;
            pair.strand2 = 2;

            kv->add(key,keybytes,(char *) &pair, sizeof(PairLink));
     } else {
            pair.chr1 = link2->chr;
            pair.chr2 = link1->chr;

            pair.pe1 = link2->pe;
            pair.pe2 = link1->pe;

            pair.loc1 = link2->loc;
            pair.loc2 = link1->loc;

            pair.strand1 = 2;
            pair.strand2 = 1;

           kv->add(key,keybytes,(char *) &pair, sizeof(PairLink));
     }

    END_BLOCK_LOOP

  }
}

void reduce_LinkID_HeadSeq(char *key, int keybytes, char *multivalue, int nvalues, int *valuebytes, KeyValue *kv, void *ptr)
{
   Data *data = (Data *) ptr;
   char *value;

   uint64_t nvalues_total;
   CHECK_FOR_BLOCKS(multivalue,valuebytes,nvalues,nvalues_total)
   BEGIN_BLOCK_LOOP(multivalue,valuebytes,nvalues)

   PairID LinkID;
   PairLink *locInfo;
   int check = 0;

   value = multivalue;
   for(int i=0; i<nvalues; i++) {
        if(valuebytes[i] == sizeof(PairLink)) {
          locInfo = (PairLink *) value;
          check = 1;
          break;
        }
        value += valuebytes[i];
   }

   if(check == 1) {

     LinkID.chr1 = locInfo->chr1;
     LinkID.chr2 = locInfo->chr2;
     LinkID.loc1 = locInfo->loc1;
     LinkID.loc2 = locInfo->loc2;

     value = multivalue;
     for(int i=0; i<nvalues; i++) {

        if(valuebytes[i] != sizeof(PairLink)) {

           string header(value);
           std::size_t pos = header.find_first_of("_");
           if(pos != std::string::npos ) {

            char *HeadSeq = (char *) malloc(sizeof(char)*(header.length()));
            memcpy(HeadSeq, header.substr(0,header.length()).c_str(), header.length());

            int scheck = 0;
            if(header.compare(pos+1,1,"1") == 0) {

              if(locInfo->pe1 == 1) { HeadSeq[pos+1] = '1'; scheck++; }
              else                  { HeadSeq[pos+1] = '2'; scheck++; }

              if(scheck > 0) kv->add((char *) &LinkID, sizeof(PairID), (char *) HeadSeq, sizeof(char)*(header.length()));

            } else if(header.compare(pos+1,1,"2") == 0) {

              if(locInfo->pe2 == 1) { HeadSeq[pos+1] = '1'; scheck++; }
              else                  { HeadSeq[pos+1] = '2'; scheck++; }


              if(scheck > 0) kv->add((char *) &LinkID, sizeof(PairID), (char *) HeadSeq, sizeof(char)*(header.length()));

            }

            free(HeadSeq);

          }
       }
       value += valuebytes[i];

     }

   }

   END_BLOCK_LOOP
}


// ############################################################################################################################
//    P-value - pcr
//    Chi-qsuare fitting for lamda
/*
void reduce_pvalue_chiSquareFit(char *key, int keybytes, char *multivalue, int nvalues, int *valuebytes, KeyValue *kv, void *ptr)
{
   Data *data = (Data *) ptr;
   char *value; 

   PairID LinkID = *(PairID *) key;

   int num_sp1 = 0;
   int num_sp2 = 0;

   std::size_t  len_consen_1, len_consen_2;

   bool overlap = false;
   int offset;
   if(LinkID.loc1 <= LinkID.loc2) offset = LinkID.loc1 + data->range - 1 - LinkID.loc2;
   else                           offset = LinkID.loc2 + data->range - 1 - LinkID.loc1;
   if( offset >= data->OVERLAP ) overlap = true;

   string ref_sequence_1, ref_sequence_2;
   string csequence_1, csequence_2;

   StripedSmithWaterman::Aligner aligner;
   StripedSmithWaterman::Filter filter;
   StripedSmithWaterman::Alignment alignment;

   IRKE irke_1(data->kmer_length, data->MAX_RECURSION, data->MIN_SEED_ENTROPY, data->MIN_SEED_COVERAGE,
             data->min_any_entropy, data->PACMAN, data->CRAWL, data->crawl_length, data->DS);

   IRKE irke_2(data->kmer_length, data->MAX_RECURSION, data->MIN_SEED_ENTROPY, data->MIN_SEED_COVERAGE,
             data->min_any_entropy, data->PACMAN, data->CRAWL, data->crawl_length, data->DS); 

  uint64_t nvalues_total;
  CHECK_FOR_BLOCKS(multivalue,valuebytes,nvalues,nvalues_total)
  BEGIN_BLOCK_LOOP(multivalue,valuebytes,nvalues)

  if(data->On_Alignment) {
    if(overlap) {
        if(LinkID.loc1 <= LinkID.loc2) ref_sequence_1 = data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc1, LinkID.loc2-LinkID.loc1+data->range-1);
        else                           ref_sequence_1 = data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc2, LinkID.loc1-LinkID.loc2+data->range-1);
    } else {
        ref_sequence_1 = data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc1, data->range);
        ref_sequence_2 = data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc2, data->range);
    }
  } else if(data->On_Assemble) {

    value = multivalue;
    for(int i=0; i<nvalues; i++) {
      string head_seq(value);
      std::size_t pos = head_seq.find_first_of(" ");

      int PE_direction = 0;
      std::size_t pe_pos = head_seq.find_first_of("_");
      if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
      if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

      string seq(head_seq.substr(pos+1,data->range).c_str() );
      string rev_seq = revcomp( seq.substr(0,data->range) );

      int nKmer = data->range - data->kmer_length + 1;
      for(int j=0; j<nKmer; j++) {

        string seq_kmer = seq.substr(j, data->kmer_length);

        if( contains_non_gatc(seq_kmer) ) {
            uint64_t kmer_val = kmer_to_intval(seq_kmer);
            uint64_t rkmer_val = revcomp_val(kmer_val, data->kmer_length);

            if(overlap) {
                irke_1.add_kmer(kmer_val , 1);
                irke_1.add_kmer(rkmer_val , 1);
            } else if(PE_direction == 1) {
                irke_1.add_kmer(kmer_val , 1);
                irke_1.add_kmer(rkmer_val , 1);
            } else {
                irke_2.add_kmer(kmer_val , 1);
                irke_2.add_kmer(rkmer_val , 1);
            }

        }

      }
      value += valuebytes[i];
    }

    irke_1.prune_some_kmers(data->min_kmer_count, data->min_any_entropy, data->prune_error_kmers, data->min_ratio_non_error);
    irke_1.populate_sorted_kmers_list();

    ref_sequence_1 =
        irke_1.compute_sequence_assemblies( data->MIN_CONNECTIVITY_RATIO, data->MIN_ASSEMBLY_LENGTH, data->MIN_ASSEMBLY_COVERAGE );

    if(!overlap) {
      irke_2.prune_some_kmers(data->min_kmer_count, data->min_any_entropy, data->prune_error_kmers, data->min_ratio_non_error);
      irke_2.populate_sorted_kmers_list();
      ref_sequence_2 =
        irke_2.compute_sequence_assemblies( data->MIN_CONNECTIVITY_RATIO, data->MIN_ASSEMBLY_LENGTH, data->MIN_ASSEMBLY_COVERAGE );
    }

  }

  int *check_error   = (int *) malloc(sizeof(int)*4);
  int *check_error_1 = (int *) malloc(sizeof(int)*4);
  int *check_error_2 = (int *) malloc(sizeof(int)*4);

  len_consen_1 = ref_sequence_1.size();
  if(!overlap) len_consen_2 = ref_sequence_2.size();

  int *loc_consensus_1  = (int *) malloc( sizeof(int) * (len_consen_1+1)*2 );
  int *loc_consensus_2;
  if(!overlap) loc_consensus_2 = (int *) malloc( sizeof(int) * (len_consen_2+1)*2 );

  int *num_consensus1 = (int *) malloc( sizeof(int) * (len_consen_1+1) * 4 * 2 );
  int *num_consensus2;

  if(overlap) num_consensus2 = (int *) malloc( sizeof(int) * (len_consen_1+1) * 4 * 2 );
  else        num_consensus2 = (int *) malloc( sizeof(int) * (len_consen_2+1) * 4 * 2 );

  for(int i=0; i<(len_consen_1+1)*2; i++) loc_consensus_1[i] = 0;
  if(!overlap)
    for(int i=0; i<(len_consen_2+1)*2; i++) loc_consensus_2[i] = 0;

  for(int i=0; i<(len_consen_1+1)*4*2; i++) num_consensus1[i] = 0;
  if(overlap) {
        for(int i=0; i<(len_consen_1+1)*4*2; i++) num_consensus2[i] = 0;
  } else {
        for(int i=0; i<(len_consen_2+1)*4*2; i++) num_consensus2[i] = 0;
  }

  if( (overlap && (len_consen_1 >= data->range) && (nvalues >= 20)) || (!overlap && (len_consen_1 >= data->range) && (len_consen_2 >= data->range) && (nvalues >= 20)) ) {

    value = multivalue;
    for(int i=0; i<nvalues; i++) {
       string head_seq(value);
       std::size_t pos    = head_seq.find_first_of(" ");

       int PE_direction = 0;
       std::size_t pe_pos = head_seq.find_first_of("_");
       if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
       if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

       string seq( head_seq.substr(pos+1,data->range).c_str() );
       string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

       if(PE_direction == 1) {

         int Strand = 0;
         Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_1, data->range);

         alignment.Clear();

         if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_1.c_str(), len_consen_1, filter, &alignment);
         else            aligner.Align(rev_seq.c_str(), ref_sequence_1.c_str(), len_consen_1, filter, &alignment);

         if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus1);
         else            get_consensus(alignment, rev_seq.c_str(), num_consensus1);

         num_sp1++;
       }

       if(PE_direction == 2) {

        int Strand = 0;
        if(overlap) Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_1, data->range);
        else        Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_2, data->range);


        alignment.Clear();
        if(overlap) {
                if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_1.c_str(), len_consen_1, filter, &alignment);
                else            aligner.Align(rev_seq.c_str(), ref_sequence_1.c_str(), len_consen_1, filter, &alignment);

                if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus2);
                else            get_consensus(alignment, rev_seq.c_str(), num_consensus2);

        } else {
                if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_2.c_str(), len_consen_2, filter, &alignment);
                else            aligner.Align(rev_seq.c_str(), ref_sequence_2.c_str(), len_consen_2, filter, &alignment);

                if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus2);
                else            get_consensus(alignment, rev_seq.c_str(), num_consensus2);
        }

        num_sp2++;
      }

      value += valuebytes[i];
    }

   int num_deletion_1 = 0;
   int num_deletion_2 = 0;

   if(data->On_Alignment) {

      if(overlap) {
        num_deletion_1 = check_deletion_consensus(num_consensus1, num_consensus2, len_consen_1, num_sp1, num_sp2);
      } else {
        num_deletion_1 = check_deletion_consensus_single(num_consensus1, len_consen_1, num_sp1);
        num_deletion_2 = check_deletion_consensus_single(num_consensus2, len_consen_2, num_sp2);
      }

      if( overlap && (num_deletion_1 > 0) ) {

          if(LinkID.loc1 <= LinkID.loc2) ref_sequence_1.assign( data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc1, LinkID.loc2-LinkID.loc1+data->range-1 + num_deletion_1) );
          else                           ref_sequence_1.assign( data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc2, LinkID.loc1-LinkID.loc2+data->range-1 + num_deletion_1) );
          len_consen_1 = ref_sequence_1.size();

          free(loc_consensus_1);
          free(num_consensus1);
          loc_consensus_1 = (int *) malloc( sizeof(int) * (len_consen_1+1) * 2 );
          num_consensus1  = (int *) malloc( sizeof(int) * (len_consen_1+1) * 4 * 2 );

          for(int i=0; i<(len_consen_1+1)*2; i++)   loc_consensus_1[i] = 0;
          for(int i=0; i<(len_consen_1+1)*4*2; i++) num_consensus1[i] = 0;
          for(int i=0; i<(len_consen_1+1)*4*2; i++) num_consensus2[i] = 0;

          value = multivalue;
          for(int i=0; i<nvalues; i++) {
             string head_seq(value);
             std::size_t pos    = head_seq.find_first_of(" ");

             int PE_direction = 0;
             std::size_t pe_pos = head_seq.find_first_of("_");
             if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
             if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

             int Strand = 0;
             Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_1, data->range);

             string seq( head_seq.substr(pos+1,data->range).c_str() );
             string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

             alignment.Clear();
             if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_1.c_str(), len_consen_1, filter, &alignment);
             else            aligner.Align(rev_seq.c_str(), ref_sequence_1.c_str(), len_consen_1, filter, &alignment);

             if(PE_direction == 1) {
               if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus1);
               else            get_consensus(alignment, rev_seq.c_str(), num_consensus1);
             }

             if(PE_direction == 2) {
               if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus2);
               else            get_consensus(alignment, rev_seq.c_str(), num_consensus2);
             }
             value += valuebytes[i];
         }

      }

      if( !overlap && (num_deletion_1 > 0) ) {

           ref_sequence_1.assign( data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc1, data->range + num_deletion_1) );
           len_consen_1 = ref_sequence_1.size();

           free(loc_consensus_1);
           free(num_consensus1);
           loc_consensus_1 = (int *) malloc( sizeof(int) * (len_consen_1+1)*2 );
           num_consensus1  = (int *) malloc( sizeof(int) * (len_consen_1+1) * 4 * 2 );

           for(int i=0; i<len_consen_1*2; i++)   loc_consensus_1[i] = 0;
           for(int i=0; i<len_consen_1*4*2; i++) num_consensus1[i] = 0;

           value = multivalue;
           for(int i=0; i<nvalues; i++) {
              string head_seq(value);
              std::size_t pos    = head_seq.find_first_of(" ");

              int PE_direction = 0;
              std::size_t pe_pos = head_seq.find_first_of("_");
              if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
              if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

              if(PE_direction == 1) {
                int Strand = 0;
                Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_1, data->range);

                string seq( head_seq.substr(pos+1,data->range).c_str() );
                string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

                alignment.Clear();

                if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_1.c_str(), len_consen_1, filter, &alignment);
                else            aligner.Align(rev_seq.c_str(), ref_sequence_1.c_str(), len_consen_1, filter, &alignment);

                if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus1);
                else            get_consensus(alignment, rev_seq.c_str(), num_consensus1);
              }

              value += valuebytes[i];
          }
      }

      if( !overlap && (num_deletion_2 > 0) ) {
           ref_sequence_2.assign( data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc2, data->range + num_deletion_2) );
           len_consen_2 = ref_sequence_2.size();

           free(loc_consensus_2);
           free(num_consensus2);
           loc_consensus_2 = (int *) malloc( sizeof(int) * (len_consen_2+1)*2 );
           num_consensus2  = (int *) malloc( sizeof(int) * (len_consen_2+1) * 4 * 2 );

           for(int i=0; i<len_consen_2*2; i++)   loc_consensus_2[i] = 0;
           for(int i=0; i<len_consen_2*4*2; i++) num_consensus2[i] = 0;

           value = multivalue;
           for(int i=0; i<nvalues; i++) {
              string head_seq(value);
              std::size_t pos    = head_seq.find_first_of(" ");

              int PE_direction = 0;
              std::size_t pe_pos = head_seq.find_first_of("_");
              if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
              if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

              if(PE_direction == 2) {
                int Strand = 0;
                Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_2, data->range);

                string seq( head_seq.substr(pos+1,data->range).c_str() );
                string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

                alignment.Clear();

                if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_2.c_str(), len_consen_2, filter, &alignment);
                else            aligner.Align(rev_seq.c_str(), ref_sequence_2.c_str(), len_consen_2, filter, &alignment);

                if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus2);
                else            get_consensus(alignment, rev_seq.c_str(), num_consensus2);
              }

             value += valuebytes[i];
           }
      }

   }



  }

  END_BLOCK_LOOP

}
*/


// #############################################################################################################################
//    P-values
//    Mixture mode for NGS & PCR errors

void reduce_pvalue_clustering(char *key, int keybytes, char *multivalue, int nvalues, int *valuebytes, KeyValue *kv, void *ptr)
{

  Data *data = (Data *) ptr;
  char *value;

  PairID LinkID = *(PairID *) key;

  int num_sp1 = 0;
  int num_sp2 = 0;

  std::size_t  len_consen_1, len_consen_2;

  bool overlap = false;
  int offset;
  if(LinkID.loc1 <= LinkID.loc2) offset = LinkID.loc1 + data->range - 1 - LinkID.loc2;
  else                           offset = LinkID.loc2 + data->range - 1 - LinkID.loc1;
  if( offset >= data->OVERLAP ) overlap = true;

  string ref_sequence_1, ref_sequence_2;
  string csequence_1, csequence_2;

  StripedSmithWaterman::Aligner aligner;
  StripedSmithWaterman::Filter filter;
  StripedSmithWaterman::Alignment alignment;
 
  IRKE irke_1(data->kmer_length, data->MAX_RECURSION, data->MIN_SEED_ENTROPY, data->MIN_SEED_COVERAGE,
             data->min_any_entropy, data->PACMAN, data->CRAWL, data->crawl_length, data->DS);

  IRKE irke_2(data->kmer_length, data->MAX_RECURSION, data->MIN_SEED_ENTROPY, data->MIN_SEED_COVERAGE,
             data->min_any_entropy, data->PACMAN, data->CRAWL, data->crawl_length, data->DS);


  uint64_t nvalues_total;
  CHECK_FOR_BLOCKS(multivalue,valuebytes,nvalues,nvalues_total)
  BEGIN_BLOCK_LOOP(multivalue,valuebytes,nvalues)

  // ***************************************************************************************************************************
  //     Reference sequences

  if(data->On_Alignment) {
    if(overlap) {
        if(LinkID.loc1 <= LinkID.loc2) ref_sequence_1 = data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc1, LinkID.loc2-LinkID.loc1+data->range-1);
        else                           ref_sequence_1 = data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc2, LinkID.loc1-LinkID.loc2+data->range-1);
    } else {
        ref_sequence_1 = data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc1, data->range);
        ref_sequence_2 = data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc2, data->range);
    }
  } else if(data->On_Assemble) {

    value = multivalue;
    for(int i=0; i<nvalues; i++) {
      string head_seq(value);
      std::size_t pos = head_seq.find_first_of(" ");

      int PE_direction = 0;
      std::size_t pe_pos = head_seq.find_first_of("_");
      if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
      if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

      string seq(head_seq.substr(pos+1,data->range).c_str() );
      string rev_seq = revcomp( seq.substr(0,data->range) );

      int nKmer = data->range - data->kmer_length + 1;
      for(int j=0; j<nKmer; j++) {

        string seq_kmer = seq.substr(j, data->kmer_length);

        if( contains_non_gatc(seq_kmer) ) {
            uint64_t kmer_val = kmer_to_intval(seq_kmer);
            uint64_t rkmer_val = revcomp_val(kmer_val, data->kmer_length);

            if(overlap) {
                irke_1.add_kmer(kmer_val , 1);
                irke_1.add_kmer(rkmer_val , 1);
            } else if(PE_direction == 1) {
                irke_1.add_kmer(kmer_val , 1);
                irke_1.add_kmer(rkmer_val , 1);
            } else {
                irke_2.add_kmer(kmer_val , 1);
                irke_2.add_kmer(rkmer_val , 1);
            }

        }

      }
      value += valuebytes[i];
    }

    irke_1.prune_some_kmers(data->min_kmer_count, data->min_any_entropy, data->prune_error_kmers, data->min_ratio_non_error);
    irke_1.populate_sorted_kmers_list();

    ref_sequence_1 =
        irke_1.compute_sequence_assemblies( data->MIN_CONNECTIVITY_RATIO, data->MIN_ASSEMBLY_LENGTH, data->MIN_ASSEMBLY_COVERAGE );

    if(!overlap) {
      irke_2.prune_some_kmers(data->min_kmer_count, data->min_any_entropy, data->prune_error_kmers, data->min_ratio_non_error);
      irke_2.populate_sorted_kmers_list();
      ref_sequence_2 =
        irke_2.compute_sequence_assemblies( data->MIN_CONNECTIVITY_RATIO, data->MIN_ASSEMBLY_LENGTH, data->MIN_ASSEMBLY_COVERAGE );
    }

  }

  int *check_error   = (int *) malloc(sizeof(int)*4);
  int *check_error_1 = (int *) malloc(sizeof(int)*4);
  int *check_error_2 = (int *) malloc(sizeof(int)*4);

  len_consen_1 = ref_sequence_1.size();
  if(!overlap) len_consen_2 = ref_sequence_2.size();

  int *loc_consensus_1  = (int *) malloc( sizeof(int) * (len_consen_1+1)*2 );
  int *loc_consensus_2;
  if(!overlap) loc_consensus_2 = (int *) malloc( sizeof(int) * (len_consen_2+1)*2 );

  int *num_consensus1 = (int *) malloc( sizeof(int) * (len_consen_1+1) * 4 * 2 );
  int *num_consensus2;

  if(overlap) num_consensus2 = (int *) malloc( sizeof(int) * (len_consen_1+1) * 4 * 2 );
  else        num_consensus2 = (int *) malloc( sizeof(int) * (len_consen_2+1) * 4 * 2 );

  for(int i=0; i<(len_consen_1+1)*2; i++) loc_consensus_1[i] = 0;
  if(!overlap)
    for(int i=0; i<(len_consen_2+1)*2; i++) loc_consensus_2[i] = 0;

  for(int i=0; i<(len_consen_1+1)*4*2; i++) num_consensus1[i] = 0;
  if(overlap) {
        for(int i=0; i<(len_consen_1+1)*4*2; i++) num_consensus2[i] = 0;
  } else {
        for(int i=0; i<(len_consen_2+1)*4*2; i++) num_consensus2[i] = 0;
  }

  if( (overlap && (len_consen_1 >= data->range) && (nvalues >= 6)) || (!overlap && (len_consen_1 >= data->range) && (len_consen_2 >= data->range) && (nvalues >= 6)) ) {

    value = multivalue;
    for(int i=0; i<nvalues; i++) {
       string head_seq(value);
       std::size_t pos    = head_seq.find_first_of(" ");

       int PE_direction = 0;
       std::size_t pe_pos = head_seq.find_first_of("_");
       if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
       if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

       string seq( head_seq.substr(pos+1,data->range).c_str() );
       string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

       if(PE_direction == 1) {

         int Strand = 0;
         Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_1, data->range);

         alignment.Clear();

         if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_1.c_str(), len_consen_1, filter, &alignment);
         else            aligner.Align(rev_seq.c_str(), ref_sequence_1.c_str(), len_consen_1, filter, &alignment);

         if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus1);
         else            get_consensus(alignment, rev_seq.c_str(), num_consensus1);

         num_sp1++;
       }

       if(PE_direction == 2) {

        int Strand = 0;
        if(overlap) Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_1, data->range);
        else        Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_2, data->range);


        alignment.Clear();
        if(overlap) {
                if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_1.c_str(), len_consen_1, filter, &alignment);
                else            aligner.Align(rev_seq.c_str(), ref_sequence_1.c_str(), len_consen_1, filter, &alignment);

                if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus2);
                else            get_consensus(alignment, rev_seq.c_str(), num_consensus2);

        } else {
                if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_2.c_str(), len_consen_2, filter, &alignment);
                else            aligner.Align(rev_seq.c_str(), ref_sequence_2.c_str(), len_consen_2, filter, &alignment);

                if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus2);
                else            get_consensus(alignment, rev_seq.c_str(), num_consensus2);
        }

        num_sp2++;
      }

      value += valuebytes[i];
    }


   // ********************************************************************************************
   //   Adjusting reference sequence fot aligment approach
   //
   int num_deletion_1 = 0;
   int num_deletion_2 = 0;

   if(data->On_Alignment) {

      if(overlap) {
        num_deletion_1 = check_deletion_consensus(num_consensus1, num_consensus2, len_consen_1, num_sp1, num_sp2);
      } else {
        num_deletion_1 = check_deletion_consensus_single(num_consensus1, len_consen_1, num_sp1);
        num_deletion_2 = check_deletion_consensus_single(num_consensus2, len_consen_2, num_sp2);
      }

      if( overlap && (num_deletion_1 > 0) ) {

          if(LinkID.loc1 <= LinkID.loc2) ref_sequence_1.assign( data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc1, LinkID.loc2-LinkID.loc1+data->range-1 + num_deletion_1) );
          else                           ref_sequence_1.assign( data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc2, LinkID.loc1-LinkID.loc2+data->range-1 + num_deletion_1) );
          len_consen_1 = ref_sequence_1.size();

          free(loc_consensus_1);
          free(num_consensus1);
          loc_consensus_1 = (int *) malloc( sizeof(int) * (len_consen_1+1) * 2 );
          num_consensus1  = (int *) malloc( sizeof(int) * (len_consen_1+1) * 4 * 2 );

          for(int i=0; i<(len_consen_1+1)*2; i++)   loc_consensus_1[i] = 0;
          for(int i=0; i<(len_consen_1+1)*4*2; i++) num_consensus1[i] = 0;
          for(int i=0; i<(len_consen_1+1)*4*2; i++) num_consensus2[i] = 0;

          value = multivalue;
          for(int i=0; i<nvalues; i++) {
             string head_seq(value);
             std::size_t pos    = head_seq.find_first_of(" ");

             int PE_direction = 0;
             std::size_t pe_pos = head_seq.find_first_of("_");
             if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
             if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

             int Strand = 0;
             Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_1, data->range);

             string seq( head_seq.substr(pos+1,data->range).c_str() );
             string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

             alignment.Clear();
             if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_1.c_str(), len_consen_1, filter, &alignment);
             else            aligner.Align(rev_seq.c_str(), ref_sequence_1.c_str(), len_consen_1, filter, &alignment);

             if(PE_direction == 1) {
               if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus1);
               else            get_consensus(alignment, rev_seq.c_str(), num_consensus1);
             }

             if(PE_direction == 2) {
               if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus2);
               else            get_consensus(alignment, rev_seq.c_str(), num_consensus2);
             }
             value += valuebytes[i];
         }

      }

      if( !overlap && (num_deletion_1 > 0) ) {

           ref_sequence_1.assign( data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc1, data->range + num_deletion_1) );
           len_consen_1 = ref_sequence_1.size();

           free(loc_consensus_1);
           free(num_consensus1);
           loc_consensus_1 = (int *) malloc( sizeof(int) * (len_consen_1+1)*2 );
           num_consensus1  = (int *) malloc( sizeof(int) * (len_consen_1+1) * 4 * 2 );

           for(int i=0; i<len_consen_1*2; i++)   loc_consensus_1[i] = 0;
           for(int i=0; i<len_consen_1*4*2; i++) num_consensus1[i] = 0;

           value = multivalue;
           for(int i=0; i<nvalues; i++) {
              string head_seq(value);
              std::size_t pos    = head_seq.find_first_of(" ");

              int PE_direction = 0;
              std::size_t pe_pos = head_seq.find_first_of("_");
              if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
              if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

              if(PE_direction == 1) {
                int Strand = 0;
                Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_1, data->range);

                string seq( head_seq.substr(pos+1,data->range).c_str() );
                string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

                alignment.Clear();

                if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_1.c_str(), len_consen_1, filter, &alignment);
                else            aligner.Align(rev_seq.c_str(), ref_sequence_1.c_str(), len_consen_1, filter, &alignment);

                if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus1);
                else            get_consensus(alignment, rev_seq.c_str(), num_consensus1);
              }

              value += valuebytes[i];
          }
      }

      if( !overlap && (num_deletion_2 > 0) ) {
           ref_sequence_2.assign( data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc2, data->range + num_deletion_2) );
           len_consen_2 = ref_sequence_2.size();

           free(loc_consensus_2);
           free(num_consensus2);
           loc_consensus_2 = (int *) malloc( sizeof(int) * (len_consen_2+1)*2 );
           num_consensus2  = (int *) malloc( sizeof(int) * (len_consen_2+1) * 4 * 2 );

           for(int i=0; i<len_consen_2*2; i++)   loc_consensus_2[i] = 0;
           for(int i=0; i<len_consen_2*4*2; i++) num_consensus2[i] = 0;

           value = multivalue;
           for(int i=0; i<nvalues; i++) {
              string head_seq(value);
              std::size_t pos    = head_seq.find_first_of(" ");

              int PE_direction = 0;
              std::size_t pe_pos = head_seq.find_first_of("_");
              if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
              if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

              if(PE_direction == 2) {
                int Strand = 0;
                Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_2, data->range);

                string seq( head_seq.substr(pos+1,data->range).c_str() );
                string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

                alignment.Clear();

                if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_2.c_str(), len_consen_2, filter, &alignment);
                else            aligner.Align(rev_seq.c_str(), ref_sequence_2.c_str(), len_consen_2, filter, &alignment);

                if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus2);
                else            get_consensus(alignment, rev_seq.c_str(), num_consensus2);
              }

             value += valuebytes[i];
           }
      }

   }
   // ********************************************************************************************

    for(int k=0; k<3; k++) { check_error[k]= 0; check_error_1[k]= 0; check_error_2[k]= 0; }
    if(overlap) { csequence_1 = check_consensus_sequence( ref_sequence_1.c_str(), check_error, num_consensus1, num_consensus2, len_consen_1, num_sp1, num_sp2, loc_consensus_1); }
    else        {
                  csequence_1 = check_consensus_seq_single( ref_sequence_1.c_str(), check_error_1, num_consensus1, len_consen_1, num_sp1, loc_consensus_1);
                  csequence_2 = check_consensus_seq_single( ref_sequence_2.c_str(), check_error_2, num_consensus2, len_consen_2, num_sp2, loc_consensus_2);
    }

    csequence_1 = csequence_1.substr(0,len_consen_1);
    if(!overlap) csequence_2 = csequence_2.substr(0,len_consen_2);

    vector<string> outName_1;
    vector<string> outName_2;

    map<string,int> outHeader_1;
    map<string,int> outHeader_2;

    map<string,int> index_read1;
    map<string,int> index_read2;

    int *READ_1, *READ_2, *Qvalue_1, *Qvalue_2;

    READ_1   = (int *) malloc( sizeof(int) * ((len_consen_1 + 1) * (num_sp1 + 1)) );
    Qvalue_1 = (int *) malloc( sizeof(int) * ((len_consen_1 + 1) * (num_sp1 + 1)) );

    for(int i=0; i<(num_sp1+1); i++) {
	for(int j=0; j<(len_consen_1+1); j++) { READ_1[i*(len_consen_1+1)+j] = 0; Qvalue_1[i*(len_consen_1+1)+j] = 0; }
    } 


    if(overlap) {
      READ_2   = (int *) malloc( sizeof(int) * ((len_consen_1 + 1) * (num_sp2 + 1)) );
      Qvalue_2 = (int *) malloc( sizeof(int) * ((len_consen_1 + 1) * (num_sp2 + 1)) );

      for(int i=0; i<(num_sp2+1); i++) {
        for(int j=0; j<(len_consen_1+1); j++) { READ_2[i*(len_consen_1+1)+j] = 0; Qvalue_2[i*(len_consen_1+1)+j] = 0; }
      }

    } else {
      READ_2   = (int *) malloc( sizeof(int) * ((len_consen_2 + 1) * (num_sp2 + 1)) );
      Qvalue_2 = (int *) malloc( sizeof(int) * ((len_consen_2 + 1) * (num_sp2 + 1)) );

      for(int i=0; i<(num_sp2+1); i++) {
        for(int j=0; j<(len_consen_2+1); j++) { READ_2[i*(len_consen_2+1)+j] = 0; Qvalue_2[i*(len_consen_2+1)+j] = 0; }
      }

   }

    if(overlap) {

      int idRead_1 = 0;
      int idRead_2 = 0;

      value = multivalue;
      for(int i=0; i<nvalues; i++) {
         string head_seq(value);
         std::size_t pos    = head_seq.find_first_of(" ");

         int PE_direction = 0;
         std::size_t pe_pos = head_seq.find_first_of("_");
         if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
         if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

         if( (PE_direction == 1) && (outHeader_1.count(head_seq.substr(0,pe_pos)) <= 0) ) {

	   outName_1.push_back( head_seq.substr(0,pe_pos) );
           outHeader_1[head_seq.substr(0,pe_pos)] = 1;
           index_read1[head_seq.substr(0,pe_pos)] = idRead_1;

           int Strand = 0;
           Get_DirectionStrand(head_seq, &PE_direction, &Strand, csequence_1, data->range);

           string seq( head_seq.substr(pos+1,data->range).c_str() );
           string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

           string quality, rev_quality;
           if(data->ftype) {
                std::size_t qos    = head_seq.find_first_of("@");
                quality.assign( head_seq.substr(qos+1,data->range).c_str(), data->range );
                rev_quality.assign( revquality( quality.substr(0,data->range) ).c_str(), data->range );
           }

           alignment.Clear();
           if(Strand == 1) aligner.Align(seq.substr(0,data->range).c_str(),     csequence_1.substr(0,len_consen_1).c_str(), len_consen_1, filter, &alignment);
           else            aligner.Align(rev_seq.substr(0,data->range).c_str(), csequence_1.substr(0,len_consen_1).c_str(), len_consen_1, filter, &alignment);

           if(Strand == 1) extract_read_quality(alignment, seq,     quality,     READ_1, Qvalue_1, idRead_1, len_consen_1, num_sp1); 
           else            extract_read_quality(alignment, rev_seq, rev_quality, READ_1, Qvalue_1, idRead_1, len_consen_1, num_sp1); 

           idRead_1++;

         }

	 if( (PE_direction == 2) && (outHeader_2.count(head_seq.substr(0,pe_pos)) <= 0) ) {

           outName_2.push_back( head_seq.substr(0,pe_pos) );
           outHeader_2[head_seq.substr(0,pe_pos)] = 1;
           index_read2[head_seq.substr(0,pe_pos)] = idRead_2;

           int Strand = 0;
           Get_DirectionStrand(head_seq, &PE_direction, &Strand, csequence_1, data->range);

           string seq( head_seq.substr(pos+1,data->range).c_str() );
           string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

           string quality, rev_quality;
           if(data->ftype) {
                std::size_t qos    = head_seq.find_first_of("@");
                quality.assign( head_seq.substr(qos+1,data->range).c_str(), data->range );
                rev_quality.assign( revquality( quality.substr(0,data->range) ).c_str(), data->range );
           }

           alignment.Clear();
           if(Strand == 1) aligner.Align(seq.substr(0,data->range).c_str(),     csequence_1.substr(0,len_consen_1).c_str(), len_consen_1, filter, &alignment);
           else            aligner.Align(rev_seq.substr(0,data->range).c_str(), csequence_1.substr(0,len_consen_1).c_str(), len_consen_1, filter, &alignment);

           if(Strand == 1) extract_read_quality(alignment, seq,     quality,     READ_2, Qvalue_2, idRead_2, len_consen_1, num_sp2);
           else            extract_read_quality(alignment, rev_seq, rev_quality, READ_2, Qvalue_2, idRead_2, len_consen_1, num_sp2);

           idRead_2++;
         }

         value += valuebytes[i];
       }

       int *Error = (int *) malloc( sizeof(int) * num_sp1 * 2);
       DecomposeError_NGS_PCR(Error, csequence_1, loc_consensus_1, len_consen_1, num_sp1, READ_1, READ_2, Qvalue_1, Qvalue_2, 13);

       for(int i=0; i<num_sp1; i++) data->ErrorNGS += (double)Error[i];
       data->flag += num_sp1;
//       for(int i=0; i<num_sp1; i++) data->lamda_ngs += (double)Error[i]; 

       kv->add((char *) Error, sizeof(int)*(num_sp1*2), (char *) &num_sp1, sizeof(int));

       free(Error);

/*
       double Mi = 0.0;
       for(int i=0; i<num_sp1; i++) Mi += (double)ePCR[i];
       Mi = Mi / (double)num_sp1;
       double G = (double)data->range * 2.0;

       double mu = (1.0 + data->lamda) * Mi / (36.0 * data->lamda * G);

       long double *OM = (long double *) malloc( sizeof(long double)*(data->side+1) );
       for(int m=0; m<=data->side; m++) OM[m] = 0.0;

       for(int i=0; i<num_sp1; i++) OM[ (int)ePCR[i] ] += 1.0; 

       long double chisq = 0.0;
       for(int m=0; m<=data->side; m++) {
            long double pv = Cal_Pm(data->lamda, mu, 36, (int)(data->range*2), (int)num_sp1, m);
            long double EM = ((long double)num_sp1) * pv;
            chisq += (OM[m] - EM) * (OM[m] - EM) / EM;
       }

       data->outFile << Mi * (double)num_sp1 << "\t" << num_sp1 << "\t" << mu << "\t" << chisq << endl;
 
       free(OM);
*/


//       data->M += Mi;
//       data->flag += num_sp1;

//       kv->add((char *) ePCR, sizeof(int)*(num_sp1), (char *) &num_sp1, sizeof(int));


//	int mMi = 0;
//        int Mi = 0;
//        for(int i=0; i<num_sp1; i++) {
//		Mi += ePCR[i];  
//		if(mMi < ePCR[i]) mMi = ePCR[i];
//	}

//        int Hij = Cal_Hamming(loc_consensus_1, len_consen_1, num_sp1, READ_1, READ_2, Qvalue_1, Qvalue_2, 20);

//	double G = (double)data->range * 2.0;
//	double n = 36.0;


//       if( (mMi <= data->side) ) {
//	  if( (Mi > 0) && (Hij > 0) ) {
//		data->Ratio += 2.0 * ((double)num_sp1-1.0)*(double)Mi*(double)Mi / (G*(double)num_sp1*((double)Hij + ((double)num_sp1-1.0)*(double)Mi));
//	  }
//	        data->flag += 1;
//          	kv->add((char *) ePCR, sizeof(int)*(num_sp1), (char *) &num_sp1, sizeof(int));	
//       }

//	if(mMi <= data->side) {
//		double Mu;
//		if( (Mi > 0) && (Hij > 0) ) Mu = 2*((double)num_sp1-1)*(double)Mi*(double)Mi / (G*(double)num_sp1*((double)Hij + ((double)num_sp1-1)*(double)Mi)); 
//		else			    Mu = 0.0;

//		kv->add((char *) ePCR, sizeof(int)*(num_sp1), (char *) &Mu, sizeof(double));
//	}

    }


    free(READ_1); free(READ_2);
    free(Qvalue_1); free(Qvalue_2);

  }

  END_BLOCK_LOOP 

}



int Cal_Hamming(int *loc_consen, int cseq_len, int num, int *READ_1, int *READ_2, int *Qvalue_1, int *Qvalue_2, int qThres)
{
   int Hij = 0;

   for(int i=0; i<(num-1); i++) 
      for(int j=i+1; j<num; j++) {
      for(int k=0; k<cseq_len; k++) {

        if( (READ_1[i*cseq_len + k] != READ_1[j*cseq_len + k]) && (READ_1[i*cseq_len + k] > 0) && (READ_1[j*cseq_len + k] > 0) ) {
		if( (loc_consen[k] ==2) && (Qvalue_1[i*cseq_len + k] > qThres) && (Qvalue_1[j*cseq_len + k] > qThres) ) Hij += 1;
	}

	if( (READ_2[i*cseq_len + k] != READ_2[j*cseq_len + k]) && (READ_2[i*cseq_len + k] > 0) && (READ_2[j*cseq_len + k] > 0) ) {
		if( (loc_consen[k] == 2) && (Qvalue_2[i*cseq_len + k] > qThres) && (Qvalue_2[j*cseq_len + k] > qThres) ) Hij += 1;
	}

      }
   }

   return Hij;
}


long double Cal_P_pcr(double lamda, double mu, int n, int G, int s, int m) 
{

    long double p = (long double)lamda * (long double)exp(-1.0 * mu * (double)G)/(1.0 + (long double)lamda * (long double)exp(-1.0 * mu * (double)G));
    long double dummy1 = (long double)pow(mu*(double)G, m) * (long double)pow(1+lamda*exp(-1*mu*(double)G), n);     
    long double dum = boost::math::factorial<long double>(m);
    long double dummy2 = dum * (long double)pow(1.0+lamda,n); 

    long double pm = 0.0;
    for(int k=0; k<=n; k++) {
        long double binc = boost::math::binomial_coefficient<long double>((long double)n, (long double)k); 
	pm += (long double)pow(k,m) * binc * (long double)pow(p,k) * (long double)pow(1-p, n-k);
    }
    pm = pm * dummy1 / dummy2;
    return pm;
}

/*
void map_extracting_Mi_ngs(uint64_t itask, char *key, int keybytes, char *value, int valuebytes, KeyValue *kv, void *ptr)
{
  Data *data = (Data *) ptr;
  int *Error = (int *) key;
  int N = *(int *) value;

  for(int i=0; i<N; i++) {
     if(Error[i] < 50)   data->Mi_ngs[ Error[i] ] += 1.0;
     if(Error[N+i] < 50) data->Mi_pcr[ Error[N + i] ] += 1.0;
  }
}
*/

void map_EM_clustering(uint64_t itask, char *key, int keybytes, char *value, int valuebytes, KeyValue *kv, void *ptr)
{
  Data *data = (Data *) ptr;
  int *Error = (int *) key;   
  int N = *(int *) value;

  int ngsMi = 0;
  for(int i=0; i<N; i++) ngsMi += Error[i];

  int pcrMi = 0;
  for(int i=N; i<(N*2); i++) pcrMi += Error[i];

  long double chisq = 0.0;
  int df = data->side;

  long double *OM = (long double *) malloc( sizeof(long double)*(df+1) );
  for(int m=0; m<=df; m++) OM[m] = 0.0;
  for(int i=0; i<N; i++) {
  //      if(Error[i] <= df) { OM[ (int)Error[i] ] += 1.0; OM[ (int)Error[N+i] ] += 1.0; }
	if(Error[i] <= df) { OM[ (int)Error[i] ] += 1.0; }
  }

//  if( (ngsMi+pcrMi) > 0 ) {

    boost::math::poisson_distribution<long double> poisson(data->lamda_ngs);

    long double w_ngs = (long double)ngsMi / ((long double)ngsMi + (long double)pcrMi);
    long double w_pcr = (long double)pcrMi / ((long double)ngsMi + (long double)pcrMi);

    // Error rate for PCR 
    double mu_pcr = (1.0 + data->lamda) * (double)pcrMi / (36.0 * data->lamda * (double)(data->range*2) * (double)N);

    // Error rate for NGS
//    long double mu_ngs = (long double)ngsMi / (long double)N;

//    data->outFile << ngsMi << "\t" << N;

    for(int m=0; m<=df; m++) {
      long double pv_pcr = Cal_P_pcr((double)data->lamda, (double)mu_pcr, 36, (int)(data->range*2), (int)N, (int)m);
      long double pv_ngs = pdf(poisson, (long double)m); 

//      long double pv_ngs;
//      if(mu_ngs > 0.0) {
//	boost::math::poisson_distribution<long double> poisson(mu_ngs);
//	pv_ngs = pdf(poisson, (long double)m);     
//      } else {	    
//	boost::math::poisson_distribution<long double> poisson(1.0e-20);
//	pv_ngs = pdf(poisson, (long double)m);
//      }

//      long double EM = (long double)N * (w_ngs*pv_ngs + w_pcr*pv_pcr);

//      long double EM = (long double)N * pv_ngs + (long double)N * pv_pcr;
//	long double EM = (long double)N * pv_ngs;

//	long double EM = (long double)N * (long double)data->Mi_ngs[m];

//        data->outFile << "\t" << OM[m] << "\t" << EM;
 
//        if(EM > 0.0) chisq += (OM[m] - EM) * (OM[m] - EM) / EM;
   }

//   data->outFile << "\t" << chisq << endl;

//  }

  boost::math::chi_squared clust_chisq(df);
  double pvalue = boost::math::cdf(clust_chisq, (double)chisq);
  pvalue = 1.0 - pvalue;

  data->outFile << ngsMi << "\t" << pcrMi << "\t" << N << "\t" << chisq << "\t" << df << "\t" << pvalue << endl;

  free(OM);

}

// ############################################################################################################
//
//   Error Cleaning - noPairing
//

void reduce_errorCorrection_noPairing(char *key, int keybytes, char *multivalue, int nvalues, int *valuebytes, KeyValue *kv, void *ptr)
{

  Data *data = (Data *) ptr;
  char *value;

  AlignInfo *alignInfo = (AlignInfo *) key;

  int num_sp1 = 0;
  int num_sp2 = 0;

  std::size_t  len_consen;

  string ref_sequence = data->reference_sequence[alignInfo->chr-1].substr(alignInfo->loc-1, data->range);

  int *check_error   = (int *) malloc(sizeof(int)*4);
  int *check_error_1 = (int *) malloc(sizeof(int)*4);
  int *check_error_2 = (int *) malloc(sizeof(int)*4);

  len_consen = ref_sequence.length();

  int *loc_consensus   = (int *) malloc( sizeof(int) * (len_consen+1)*2 );

  int *num_consensus1  = (int *) malloc( sizeof(int) * (len_consen+1) * 4 * 2 );
  int *num_consensus2  = (int *) malloc( sizeof(int) * (len_consen+1) * 4 * 2 );

  int *numCSEN  = (int *) malloc( sizeof(int) * (len_consen+1) * 4 * 2 );

  for(int i=0; i<(len_consen+1)*2; i++) loc_consensus[i] = 0;

  for(int i=0; i<(len_consen+1)*4*2; i++) num_consensus1[i] = 0;
  for(int i=0; i<(len_consen+1)*4*2; i++) num_consensus2[i] = 0;
  for(int i=0; i<(len_consen+1)*4*2; i++) numCSEN[i] = 0;

  StripedSmithWaterman::Aligner aligner;
  StripedSmithWaterman::Filter filter;
  StripedSmithWaterman::Alignment alignment;

  int *index_print = (int *) malloc( sizeof(int) * nvalues );
  for(int i=0; i<nvalues; i++) index_print[i] = 0;

  int Strand, PE_direction;
  string head_seq, csequence;
  stringstream out_string;

  uint64_t nvalues_total;
  CHECK_FOR_BLOCKS(multivalue,valuebytes,nvalues,nvalues_total)
  BEGIN_BLOCK_LOOP(multivalue,valuebytes,nvalues)     

  if(nvalues >= data->depth) {

    value = multivalue;
    for(int i=0; i<nvalues; i++) {
       head_seq.assign(value, valuebytes[i]);
       std::size_t pos  = head_seq.find_first_of(" ");

       string seq( head_seq.substr(pos+1,data->range).c_str() );
       string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

       Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence.substr(0,data->range).c_str(), data->range);

       alignment.Clear();
 
       if(PE_direction == 1) {
         if(Strand == 1) {
		aligner.Align(seq.c_str(),     ref_sequence.c_str(), len_consen, filter, &alignment);
		get_consensus(alignment, seq.c_str(),     num_consensus1);
         } else {
       		aligner.Align(rev_seq.c_str(), ref_sequence.c_str(), len_consen, filter, &alignment);
		get_consensus(alignment, rev_seq.c_str(), num_consensus1);
         }
         num_sp1++;
       } else {
         if(Strand == 1) {
                aligner.Align(seq.c_str(),     ref_sequence.c_str(), len_consen, filter, &alignment);
                get_consensus(alignment, seq.c_str(),     num_consensus2);
         } else {
                aligner.Align(rev_seq.c_str(), ref_sequence.c_str(), len_consen, filter, &alignment);
                get_consensus(alignment, rev_seq.c_str(), num_consensus2);
         }
         num_sp2++;
       }

       value += valuebytes[i];
    }


  if( (num_sp1+num_sp2) >= data->depth ) {

        for(int k=0; k<3; k++) { check_error[k]= 0; check_error_1[k]= 0; check_error_2[k]= 0; }
        string tmp_csequence = check_consensus_sequence_iDES( ref_sequence.c_str(), check_error, num_consensus1, num_consensus2, numCSEN, len_consen, num_sp1, num_sp2, loc_consensus);
        csequence.assign( tmp_csequence.substr(0,len_consen).c_str(), len_consen );

        float depth = (float)(num_sp1+num_sp2);
        float f = log(data->error_rate) / (-1 * depth);

        for(int k=0; k<len_consen; k++) {

                int id1 = 0;
                int mx1 = numCSEN[k*4];
                for(int j=1; j<4; j++) {
                        if(numCSEN[k*4+j] > mx1) {
                                mx1 = numCSEN[k*4+j];
                                id1 = j;
                        }
                }

                int id2 = -1;
                int mx2 = -1;
                for(int j=0; j<4; j++) {
                        if( (numCSEN[k*4+j]>0) && (numCSEN[k*4+j] > mx2) && (numCSEN[k*4+j] < mx1) ) {
                                mx2 = numCSEN[k*4+j];
                                id2 = j;
                        }
                }

                float af = (float)numCSEN[k*4+id1] / depth;
                numCSEN[k*4+id1] = 1;

                if(id2 > 0) {
                        af = (float)numCSEN[k*4+id2] / depth;
                        if(af > f) numCSEN[k*4+id2] = 1;
                        else       numCSEN[k*4+id2] = 0;
                }

                for(int j=0; j<4; j++) {
                   if( (j != id1) && (j != id2) ) numCSEN[k*4+j] = 0;
                }

        }


        value = multivalue;
        for(int i=0; i<nvalues; i++) {

                head_seq.assign(value, valuebytes[i]);

                std::size_t pos    = head_seq.find_first_of(" ");
                std::size_t pe_pos = head_seq.find_first_of("_");

                Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence, data->range);

                string seq     = head_seq.substr(pos+1,data->range).c_str();
                string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

                string quality;
                if(data->ftype) quality.assign(head_seq.substr(pos + data->range + 2, data->range).c_str(), data->range);

                alignment.Clear();
                if(Strand == 1) aligner.Align(seq.c_str(),     csequence.substr(0,len_consen).c_str(),len_consen, filter, &alignment);
                else            aligner.Align(rev_seq.c_str(), csequence.substr(0,len_consen).c_str(),len_consen, filter, &alignment);

                  int str_len = data->range;
                  string clean_read, clean_quality;
                  if(Strand == 1)  {
                          string tmp_string = get_cleanRead_FQ(csequence.substr(0,len_consen).c_str(),alignment, seq.c_str(), quality.c_str(), &str_len, numCSEN, len_consen, data->error_rate);

                          clean_read.assign(   tmp_string.substr(0,         str_len).c_str(), str_len);
                          clean_quality.assign(tmp_string.substr(str_len+1, str_len).c_str(), str_len);
                  } else {
                          string rev_quality = revquality( quality.substr(0,data->range).c_str() );
                          string tmp_string  = get_cleanRead_FQ(csequence.substr(0,len_consen).c_str(),alignment, rev_seq.c_str(), rev_quality.c_str(), &str_len, numCSEN, len_consen, data->error_rate);

                          string rtmp_string  = revcomp(    tmp_string.substr(0,         str_len).c_str() );
                          string rtmp_quality = revquality( tmp_string.substr(str_len+1, str_len).c_str() );

                          clean_read.assign(    rtmp_string.substr(0,str_len).c_str(), str_len );
                          clean_quality.assign( rtmp_quality.substr(0,str_len).c_str(), str_len );
                 }

                 if( clean_read.length() >= (data->range-2) ) {

                     out_string.str(std::string());

                     if(data->ftype) {
                        out_string << "@" << head_seq.substr(0,pe_pos).c_str() << " " << head_seq.substr(pe_pos+1,pos-pe_pos-1).c_str() << endl
                                   << clean_read.substr(0,clean_read.length()).c_str() << endl
                                   << "+" << endl << clean_quality.substr(0,clean_quality.length()).c_str();

                     } else {
                        out_string << ">" << head_seq.substr(0,pe_pos).c_str() << " " << head_seq.substr(pe_pos+1,pos-pe_pos-1).c_str() << endl
                                   << clean_read.substr(0,clean_read.length()).c_str();
                     }

                     data->outFile_R1 << out_string.str().c_str() << endl;
                     index_print[i] = 1;

               }

              value += valuebytes[i];
        }

    }

  }


        value = multivalue;
        for(int i=0; i<nvalues; i++) {
         if(index_print[i] == 0) {

            head_seq.assign(value, valuebytes[i]);
            std::size_t pos = head_seq.find_first_of(" ");
            std::size_t pe_pos = head_seq.find_first_of("_");

            string seq     = head_seq.substr(pos+1,data->range).c_str();

            string quality;
            if(data->ftype)
                quality.assign( head_seq.substr(pos + data->range + 2, data->range).c_str(), data->range );

            out_string.str(std::string());
            if(data->ftype) {
                out_string << "@" << head_seq.substr(0,pe_pos).c_str() << " " << head_seq.substr(pe_pos+1,pos-pe_pos-1).c_str() << endl
                           << seq.substr(0,seq.length()).c_str() << endl
                           << "+" << endl << quality.substr(0,seq.length()).c_str();

            } else {
               out_string << ">" << head_seq.substr(0,pe_pos).c_str() << " " << head_seq.substr(pe_pos+1,pos-pe_pos-1).c_str() << endl
                          << seq.substr(0,seq.length()).c_str();
            }
            data->outFile_R1 << out_string.str().c_str() << endl;

         }
         value += valuebytes[i];
      }

  END_BLOCK_LOOP

  free(index_print);

  free(check_error);
  free(check_error_1);
  free(check_error_2);

  free(loc_consensus);

  free(num_consensus1);
  free(num_consensus2);
  free(numCSEN);

}





/*
    for(int k=0; k<3; k++) { check_error[k]= 0; check_error_1[k]= 0; check_error_2[k]= 0; }
    string csequence = check_consensus_sequence_iDES( ref_sequence.c_str(), check_error, num_consensus1, num_consensus2, numCSEN, len_consen, num_sp1, num_sp2, loc_consensus);
    csequence = csequence.substr(0,len_consen);

    if(num_sp1 > 2) {

    	value = multivalue;
    	for(int i=0; i<nvalues; i++) {

       		string head_seq(value);
       		std::size_t pos    = head_seq.find_first_of(" ");
       		std::size_t pe_pos = head_seq.find_first_of("_");

       		int PE_direction = 0;

       		if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
       		if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

       		int Strand = 0;
       		Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence, data->range);

       		string seq     = head_seq.substr(pos+1,data->range).c_str();
       		string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

       		string quality;
       		if(data->ftype) {
       			quality = head_seq.substr(pos+data->range+2, data->range).c_str();	
		}

       		int str_len;

       		if( PE_direction==1 ) {

                      alignment.Clear();
                      if(Strand == 1) aligner.Align(seq.c_str(),     csequence.substr(0,len_consen).c_str(),len_consen, filter, &alignment);
                      else            aligner.Align(rev_seq.c_str(), csequence.substr(0,len_consen).c_str(),len_consen, filter, &alignment);

                      str_len = data->range;
                      string clean_read1, clean_quality1;
		      if(Strand == 1)  {
				       string tmp_string = get_cleanRead_FQ(csequence.substr(0,len_consen).c_str(),alignment, seq.c_str(), quality.c_str(), &str_len, numCSEN, len_consen, data->error_rate);

				       if( ((data->range-str_len) < 2) && (tmp_string.length() == (str_len*2+1)) ) {
				         clean_read1    = tmp_string.substr(0,         str_len).c_str();
				         clean_quality1 = tmp_string.substr(str_len+1, str_len).c_str();
			       	       }
                      } else {
				       string rev_quality = revquality( quality.substr(0,data->range).c_str() );
				       string tmp_string = get_cleanRead_FQ(csequence.substr(0,len_consen).c_str(),alignment, rev_seq.c_str(), rev_quality.c_str(), &str_len, numCSEN, len_consen, data->error_rate); 

				       if( ((data->range-str_len) < 2) && (tmp_string.length() == (str_len*2+1)) ) {
				         clean_read1     = revcomp(    tmp_string.substr(0,         str_len).c_str() );
				         clean_quality1  = revquality( tmp_string.substr(str_len+1, str_len).c_str() );
				       }
		      }


		      if( clean_read1.length() >= (data->range-5) ) {
			  for(int j=0; j<str_len; j++) {
			    if(data->ftype) {
                              int qscore = get_Qscore(clean_quality1.at(j));
                              if( (qscore < 0) || (qscore > 42) ) clean_quality1.replace(j,1,1,'!');
			    }

                            int Base = get_int_from_base(clean_read1.at(j));
                            if( (Base < 0) || (Base > 3) ) clean_read1.replace(j,1,1,'N');
                          }

                         if(data->ftype) {
			      data->outFile_R1 << "@" << head_seq.substr(0,pe_pos).c_str() << " " << head_seq.substr(pe_pos+1,pos-pe_pos-1).c_str() << endl;
                              data->outFile_R1 << clean_read1.substr(0,str_len).c_str() << endl;
                              data->outFile_R1 << "+" << endl << clean_quality1.substr(0,str_len).c_str() << endl;
			 } else {
			      data->outFile_R1 << ">" << head_seq.substr(0,pe_pos).c_str() << " " << head_seq.substr(pe_pos+1,pos-pe_pos-1).c_str() << endl;
                              data->outFile_R1 << clean_read1.substr(0,str_len).c_str() << endl;
			 }
		
			 index_print[i] = 1;
	
                      } else {

                         if(data->ftype) {
			        data->outFile_R1 << "@" << head_seq.substr(0,pe_pos).c_str() << " " << head_seq.substr(pe_pos+1,pos-pe_pos-1).c_str() << endl;
                         	data->outFile_R1 << seq.substr(0,data->range).c_str() << endl;
                         	data->outFile_R1 << "+" << endl << quality.substr(0,data->range).c_str() << endl;
			 } else {
				data->outFile_R1 << ">" << head_seq.substr(0,pe_pos).c_str() << " " << head_seq.substr(pe_pos+1,pos-pe_pos-1).c_str() << endl;
                         	data->outFile_R1 << seq.substr(0,data->range).c_str() << endl;
			 }


			 index_print[i] = 1;

		     }

       		}

		value += valuebytes[i];
	}
    }  

    if(num_sp2 > 2) {

	value = multivalue;
        for(int i=0; i<nvalues; i++) {

                string head_seq(value);
                std::size_t pos    = head_seq.find_first_of(" ");
                std::size_t pe_pos = head_seq.find_first_of("_");

                int PE_direction = 0;

                if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
                if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

                int Strand = 0;
                Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence, data->range);

                string seq     = head_seq.substr(pos+1,data->range).c_str();
                string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

                string quality;
                if(data->ftype) {
		        quality = head_seq.substr(pos+data->range+2, data->range).c_str();
                }

                int str_len;

       		if( PE_direction==2 ) {

                       alignment.Clear();
                       if(Strand == 1) aligner.Align(seq.c_str(),     csequence.substr(0,len_consen).c_str(),len_consen, filter, &alignment);
                       else            aligner.Align(rev_seq.c_str(), csequence.substr(0,len_consen).c_str(),len_consen, filter, &alignment);

                       str_len = data->range;
                       string clean_read2, clean_quality2;
		       if(Strand == 1)  {
					string tmp_string = get_cleanRead_FQ(csequence.substr(0,len_consen).c_str(),alignment, seq.c_str(), quality.c_str(), &str_len, numCSEN, len_consen, data->error_rate);

					if( ((data->range-str_len) < 2) && (tmp_string.length() == (str_len*2+1)) ) { 
					  clean_read2    = tmp_string.substr(0,str_len).c_str();
                                          clean_quality2 = tmp_string.substr(str_len+1, str_len).c_str();
					}
                       } else {
					string rev_quality = revquality( quality.substr(0,data->range).c_str() );
                                        string tmp_string = get_cleanRead_FQ(csequence.substr(0,len_consen).c_str(),alignment, rev_seq.c_str(), rev_quality.c_str(), &str_len, numCSEN, len_consen, data->error_rate);

					if( ((data->range-str_len) < 2) && (tmp_string.length() == (str_len*2+1)) ) { 
                                          clean_read2    = revcomp(    tmp_string.substr(0,str_len).c_str() );
                                          clean_quality2 = revquality( tmp_string.substr(str_len+1, str_len).c_str() );
					}
		       }

		       if( clean_read2.length() >= (data->range-5) ) {
			  for(int j=0; j<str_len; j++) {
			    if(data->ftype) {
                              int qscore = get_Qscore(clean_quality2.at(j));
                              if( (qscore < 0) || (qscore > 42) ) clean_quality2.replace(j,1,1,'!');
			    }

                              int Base = get_int_from_base(clean_read2.at(j));
                              if( (Base < 0) || (Base > 3) ) clean_read2.replace(j,1,1,'N');
                          }

                         if(data->ftype) {
			      data->outFile_R1 << "@" << head_seq.substr(0,pe_pos).c_str() << " " << head_seq.substr(pe_pos+1,pos-pe_pos-1).c_str() << endl;
                              data->outFile_R1 << clean_read2.substr(0,str_len).c_str() << endl;
                              data->outFile_R1 << "+" << endl << clean_quality2.substr(0,str_len).c_str() << endl;
			 } else {
			      data->outFile_R1 << ">" << head_seq.substr(0,pe_pos).c_str() << " " << head_seq.substr(pe_pos+1,pos-pe_pos-1).c_str() << endl;
                              data->outFile_R1 << clean_read2.substr(0,str_len).c_str() << endl;
			 }

			 index_print[i] = 0;

                       } else {

                          if(data->ftype) {
				data->outFile_R1 << "@" << head_seq.substr(0,pe_pos).c_str() << " " << head_seq.substr(pe_pos+1,pos-pe_pos-1).c_str() << endl;
                          	data->outFile_R1 << seq.substr(0,data->range).c_str() << endl;
				data->outFile_R1 << "+" << endl << quality.substr(0,data->range).c_str() << endl;
			  } else {
				data->outFile_R1 << ">" << head_seq.substr(0,pe_pos).c_str() << " " << head_seq.substr(pe_pos+1,pos-pe_pos-1).c_str() << endl;
                          	data->outFile_R1 << seq.substr(0,data->range).c_str() << endl;		
			  } 

			  index_print[i] = 0;

                      }

	        }

                value += valuebytes[i];
        }
    

   }

*/

/*
  string csequence;

   if( (num_sp1 > 5) || (num_sp2 > 5) ) {
     for(int k=0; k<3; k++) { check_error[k]= 0; check_error_1[k]= 0; check_error_2[k]= 0; }
     csequence = check_consensus_sequence_iDES( ref_sequence.c_str(), check_error, num_consensus1, num_consensus2, numCSEN, len_consen, num_sp1, num_sp2, loc_consensus);
     csequence = csequence.substr(0,len_consen);
   }

   if(num_sp1 > 5) {
        print_cleanReads_FQ_noPairing(1,  numCSEN, ref_sequence, csequence, len_consen, alignment, filter,
                                   multivalue, nvalues, valuebytes, data->range,  data->outFile_R1, data->ftype, index_print, data->error_rate);
   }
   if(num_sp2 > 5) {
        print_cleanReads_FQ_noPairing(2,  numCSEN, ref_sequence, csequence, len_consen, alignment, filter,
                                   multivalue, nvalues, valuebytes, data->range,  data->outFile_R1, data->ftype, index_print, data->error_rate);
   }
*/


/*
                int af_loc = LOC - alignInfo->loc;

                data->outFile << alignInfo->chr << " "
                              << alignInfo->loc << " "
                              << LOC << " "
                              << ref_sequence.c_str()[af_loc] << " "
                              << csequence.c_str()[af_loc] << " "
                              << numCSEN[af_loc*4] << " "
                              << numCSEN[af_loc*4+1] << " "
                              << numCSEN[af_loc*4+2] << " "
                              << numCSEN[af_loc*4+3] << endl;

*/


//                  print_cleanReads_FQ_noPairing(numCSEN, ref_sequence.c_str(), csequence.c_str(), len_consen, alignment, filter,
//                                   multivalue, nvalues, valuebytes, data->range,  data->outFile_R1, data->ftype, index_print, data->error_rate);



/*
	if(num_sp1 > 0) {
	int pe_index, 
		  print_cleanReads_FQ_noPairing(1,  numCSEN, ref_sequence.c_str(), csequence.c_str(), len_consen, alignment, filter,
                                   multivalue, nvalues, valuebytes, data->range,  data->outFile_R1, data->ftype, index_print, data->error_rate);
	}

	if(num_sp2 > 0) {
                print_cleanReads_FQ_noPairing(2,  numCSEN, ref_sequence.c_str(), csequence.c_str(), len_consen, alignment, filter,
                                   multivalue, nvalues, valuebytes, data->range,  data->outFile_R1, data->ftype, index_print, data->error_rate);
	}
*/


 
//   print_unCleaned_noPairing(multivalue, nvalues, valuebytes, data->range, data->outFile_R1, data->ftype, index_print);	



void print_unCleaned_noPairing(char *multivalue, int nvalues, int *valuebytes, int data_range, std::ofstream &outFile, bool ftype, int *index_print)
{

    string head_seq;
    string seq;
    char *value = multivalue;
    for(int i=0; i<nvalues; i++) {
      if(index_print[i] == 0) {
	    head_seq.assign(value, valuebytes[i]);
            std::size_t pos = head_seq.find_first_of(" ");
            seq.assign( head_seq.substr(pos+1,data_range).c_str(), data_range );

            string quality;
            if(ftype) 
		quality.assign( head_seq.substr(pos + seq.length() + 2, seq.length()).c_str(), seq.length() );

            std::size_t pe_pos = head_seq.find_first_of("_");
            if(ftype) {
		outFile << "@" << head_seq.substr(0,pe_pos).c_str() << " " << head_seq.substr(pe_pos+1,pos-pe_pos-1).c_str() << endl;
                outFile << seq.substr(0,seq.length()).c_str() << endl;
		outFile << "+" << endl << quality.substr(0,seq.length()).c_str() << endl;

	    } else {
		outFile << ">" << head_seq.substr(0,pe_pos).c_str() << " " << head_seq.substr(pe_pos+1,pos-pe_pos-1).c_str() << endl;
                outFile << seq.substr(0,seq.length()).c_str() << endl;
	    }

      }
      value += valuebytes[i];
   }

}


void print_cleanReads_FQ_noPairing(
	int *numCSEN,
	string ref_sequence, 
	string csequence,
	int len_consen,
	StripedSmithWaterman::Alignment alignment, 
	StripedSmithWaterman::Filter filter,
	char *multivalue, 
	int nvalues, 
	int *valuebytes, 
	int data_range, 
	std::ofstream &outFile, 
	bool ftype, 
	int *index_print, 
	float error_rate ) 
{
	StripedSmithWaterman::Aligner aligner;

	string head_seq;
	string clean_read, clean_quality;
        char *value = multivalue;
        for(int i=0; i<nvalues; i++) {

	        head_seq.assign(value, valuebytes[i]);

                std::size_t pos    = head_seq.find_first_of(" ");
                std::size_t pe_pos = head_seq.find_first_of("_");

                int PE_direction = 0;

                  int Strand = 0;
                  Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence, data_range);

                  string seq     = head_seq.substr(pos+1,data_range).c_str();
                  string rev_seq = revcomp( seq.substr(0,data_range).c_str() );

                  string quality;
                  if(ftype) quality.assign(head_seq.substr(pos + data_range + 2, data_range).c_str(), data_range);


                  alignment.Clear();
                  if(Strand == 1) aligner.Align(seq.c_str(),     csequence.substr(0,len_consen).c_str(),len_consen, filter, &alignment);
                  else            aligner.Align(rev_seq.c_str(), csequence.substr(0,len_consen).c_str(),len_consen, filter, &alignment);

                  int str_len = data_range;
                  if(Strand == 1)  {
                          string tmp_string = get_cleanRead_FQ(csequence.substr(0,len_consen).c_str(),alignment, seq.c_str(), quality.c_str(), &str_len, numCSEN, len_consen, error_rate);

                          clean_read.assign(   tmp_string.substr(0,         str_len).c_str(), str_len);
                          clean_quality.assign(tmp_string.substr(str_len+1, str_len).c_str(), str_len);
                  } else {
                          string rev_quality = revquality( quality.substr(0,data_range).c_str() );
                          string tmp_string = get_cleanRead_FQ(csequence.substr(0,len_consen).c_str(),alignment, rev_seq.c_str(), rev_quality.c_str(), &str_len, numCSEN, len_consen, error_rate);

			  string rtmp_string = revcomp(    tmp_string.substr(0,         str_len).c_str() );
			  string rtmp_quality = revquality( tmp_string.substr(str_len+1, str_len).c_str() );

                          clean_read.assign(    rtmp_string.substr(0,str_len).c_str(), str_len );
                          clean_quality.assign( rtmp_quality.substr(0,str_len).c_str(), str_len );
                 }

                 if( clean_read.length() >= (data_range-2) ) {

                     if(ftype) {
                        outFile << "@" << head_seq.substr(0,pe_pos).c_str() << " " << head_seq.substr(pe_pos+1,pos-pe_pos-1).c_str() << endl;
                        outFile << clean_read.substr(0,clean_read.length()).c_str() << endl;
                        outFile << "+" << endl << clean_quality.substr(0,clean_quality.length()).c_str() << endl;
                     } else {
                        outFile << ">" << head_seq.substr(0,pe_pos).c_str() << " " << head_seq.substr(pe_pos+1,pos-pe_pos-1).c_str() << endl;
                        outFile << clean_read.substr(0,clean_read.length()).c_str() << endl;
                     }

                     index_print[i] = 1;

               }

            value += valuebytes[i];
        }


        value = multivalue;
        for(int i=0; i<nvalues; i++) {
         if(index_print[i] == 0) {

            head_seq.assign(value, valuebytes[i]);
            std::size_t pos = head_seq.find_first_of(" ");
	    std::size_t pe_pos = head_seq.find_first_of("_");

	    string seq     = head_seq.substr(pos+1,data_range).c_str();
	    
            string quality;
            if(ftype)
                quality.assign( head_seq.substr(pos + data_range + 2, data_range).c_str(), data_range );

            if(ftype) {
                outFile << "@" << head_seq.substr(0,pe_pos).c_str() << " " << head_seq.substr(pe_pos+1,pos-pe_pos-1).c_str() << endl;
                outFile << seq.substr(0,seq.length()).c_str() << endl;
                outFile << "+" << endl << quality.substr(0,seq.length()).c_str() << endl;

            } else {
                outFile << ">" << head_seq.substr(0,pe_pos).c_str() << " " << head_seq.substr(pe_pos+1,pos-pe_pos-1).c_str() << endl;
                outFile << seq.substr(0,seq.length()).c_str() << endl;
            }

         }
         value += valuebytes[i];
      }

}



void print_clusteredReads_noPairing(
	int *idRead, 
	string csequence, 
	int len_consen, 
	int num_sp, 
	char *multivalue, 
	int nvalues, 
	int *valuebytes, 
	int data_range, 
	std::ofstream &outFile, 
	bool ftype,
	int pe_index, int32_t *bam_cigar )
{
//    int32_t *bam_cigar = (int32_t *) malloc( sizeof(int32_t)*3 );

    int sloc, sp, sp_loc;

    string head_seq;
    char *value = multivalue;
    for(int i=0; i<nvalues; i++) {

        head_seq.assign(value, valuebytes[i]);
        std::size_t pos    = head_seq.find_first_of(" ");

//     if(pos != std::string::npos ) {

       int PE_direction = 0;
       int Strand = 0;
       Get_DirectionStrand(head_seq.c_str(), &PE_direction, &Strand, csequence.substr(0,len_consen).c_str(), data_range);

       if( PE_direction == pe_index ) {

	 stringstream ss_out;
         ss_out.str(std::string()); 

	 string quality, seq;

	 seq.assign( head_seq.substr(pos+1,data_range).c_str(), data_range );
         if(ftype) quality.assign(head_seq.substr(pos + data_range + 2, data_range).c_str(), data_range);

	 sloc = *idRead * len_consen;

	 bool if_aligned;

    	 StripedSmithWaterman::Aligner aligner;
    	 StripedSmithWaterman::Filter filter;
    	 StripedSmithWaterman::Alignment alignment;

         if(Strand == 1) {

	    aligner.Align(seq.c_str(), csequence.c_str(), csequence.size(), filter, &alignment);

//  if_aligned = check_alignment(alignment, data_range, len_consen);
//  if(if_aligned) {

            if( (alignment.ref_begin - alignment.query_begin) >= 0 ) {
               for(int j=0; j<abs( (int)(alignment.ref_begin-alignment.query_begin) ); j++)  ss_out << " ";   //fprintf(outFile,"%c", ' '); //ss_out << " ";
	       if( (int)alignment.query_begin>0 )  ss_out << seq.substr(0,(int)alignment.query_begin).c_str();   //fprintf(outFile, "%s", seq.substr(0,(int)alignment.query_begin).c_str() );  //ss_out << seq.substr(0,(int)alignment.query_begin).c_str();
	    } else {
		     int ss = (int)(alignment.query_begin - alignment.ref_begin);
                     if((int)alignment.ref_begin > 0) ss_out << seq.substr(ss,(int)alignment.ref_begin).c_str();  //fprintf(outFile, "%s", seq.substr(ss,(int)alignment.ref_begin).c_str() );   //ss_out << seq.substr(ss,(int)alignment.ref_begin).c_str();
            } 

            sp     = (int)alignment.query_begin;
            sp_loc = (int)alignment.ref_begin;
//            for(size_t j = 0; j < alignment.cigar.size(); j++)  {
	    for (std::vector<uint32_t>::iterator it = alignment.cigar.begin() ; it != alignment.cigar.end(); ++it) { 
//                 convert_cigar2bam(alignment.cigar[j], bam_cigar);
		  convert_cigar2bam(*it, bam_cigar);

                  if( (bam_cigar[0] == 0) || (bam_cigar[0] == 7) || (bam_cigar[0] == 8) ) {
			   ss_out << seq.substr(sp,(int)bam_cigar[1]).c_str();
//                           fprintf(outFile,"%s", seq.substr(sp,(int)bam_cigar[1]).c_str());   //ss_out << seq.substr(sp,(int)bam_cigar[1]).c_str();
                           sp     += (int)bam_cigar[1];
                           sp_loc += (int)bam_cigar[1];

                  } else if( bam_cigar[0] == 2 )  {
                           for(int k=0; k<(int)bam_cigar[1]; k++) ss_out << "-";   //fprintf(outFile, "%c", '-');  //ss_out << "-";
                           sp_loc += (int)bam_cigar[1];
                  } else if( bam_cigar[0] == 1) {
			    sp     += (int)bam_cigar[1];
		  }
	    }
	    if(bam_cigar[0] == 4) ss_out << seq.substr(sp,(int)bam_cigar[1]).c_str();  // fprintf(outFile, "%s", seq.substr(sp,seq.length()-sp).c_str());    // ss_out << seq.substr(sp,(int)bam_cigar[1]).c_str();
	    ss_out << " --- " << head_seq.substr(0,pos).c_str() << " " << Strand;
	    //fprintf(outFile,"%s%s%c%d", " --- ", head_seq.substr(0,pos).c_str(), ' ', Strand);
//    }

	 } else {

	    string rev_seq = revcomp( seq.substr(0,data_range).c_str() );
            aligner.Align(rev_seq.c_str(), csequence.c_str(), csequence.size(), filter, &alignment);

//  if_aligned = check_alignment(alignment, data_range, len_consen);
//  if(if_aligned) {

	    if( (alignment.ref_begin - alignment.query_begin) >= 0 ) {
               for(int j=0; j<abs( (int)(alignment.ref_begin-alignment.query_begin) ); j++)  ss_out << " ";  //fprintf(outFile,"%c", ' ');  //ss_out << " ";
               if( (int)alignment.query_begin>0 ) ss_out << rev_seq.substr(0,(int)alignment.query_begin).c_str();   //fprintf(outFile, "%s", rev_seq.substr(0,(int)alignment.query_begin).c_str() );  //ss_out << rev_seq.substr(0,(int)alignment.query_begin).c_str();
            } else {
                     int ss = (int)(alignment.query_begin - alignment.ref_begin);
                     if((int)alignment.ref_begin > 0) ss_out << rev_seq.substr(ss,(int)alignment.ref_begin).c_str();    //fprintf(outFile, "%s", rev_seq.substr(ss,(int)alignment.ref_begin).c_str() );   //ss_out << rev_seq.substr(ss,(int)alignment.ref_begin).c_str();
            }

            sp     = (int)alignment.query_begin;
            sp_loc = (int)alignment.ref_begin;
            for(size_t j = 0; j < alignment.cigar.size(); j++)  {
                  convert_cigar2bam(alignment.cigar[j], bam_cigar);

                  if( (bam_cigar[0] == 0) || (bam_cigar[0] == 7) || (bam_cigar[0] == 8) ) {
			   ss_out << rev_seq.substr(sp,(int)bam_cigar[1]).c_str();
//                           fprintf(outFile,"%s", rev_seq.substr(sp,(int)bam_cigar[1]).c_str());   //ss_out << rev_seq.substr(sp,(int)bam_cigar[1]).c_str();
                           sp     += (int)bam_cigar[1];
                           sp_loc += (int)bam_cigar[1];

                  } else if( bam_cigar[0] == 2 )  {
                           for(int k=0; k<(int)bam_cigar[1]; k++) ss_out << "-";   //fprintf(outFile, "%c", '-'); //ss_out << "-";
                           sp_loc += (int)bam_cigar[1];
                  } else if( bam_cigar[0] == 1) {
                            sp     += (int)bam_cigar[1];
                  }
            }
            if(bam_cigar[0] == 4) ss_out << rev_seq.substr(sp,(int)bam_cigar[1]).c_str();  //fprintf(outFile, "%s", rev_seq.substr(sp,rev_seq.length()-sp).c_str());  //ss_out << rev_seq.substr(sp,(int)bam_cigar[1]).c_str();
	    ss_out << " --- " << head_seq.substr(0,pos).c_str() << " " << Strand; 	
	     //fprintf(outFile,"%s%s%c%d", " --- ", head_seq.substr(0,pos).c_str(), ' ', Strand);

//  }

      }

	outFile << ss_out.str().c_str() << endl;
//	fprintf(outFile, "\n");
        *idRead++;

       }

//    }

     value += valuebytes[i];
   }

//   free(bam_cigar);
}

void map_print_outSNV(uint64_t itask, char *key, int keybytes, char *value, int valuebytes, KeyValue *kv, void *ptr)
{
  Data *data = (Data *) ptr;

  int chrLoc = *(int *) key;
  OutSNV *outsnv = (OutSNV *) value;

  data->outFile << chrLoc << "\t" << outsnv->ref_allele << "\t" << outsnv->tdepth << "\t" << outsnv->f << "\t" << outsnv->af0 << "\t" << outsnv->af1 << "\t" << outsnv->af2 << "\t" << outsnv->af3 << endl;
}


void reduce_call_Variant(char *key, int keybytes, char *multivalue, int nvalues, int *valuebytes, KeyValue *kv, void *ptr)
{
  Data *data = (Data *) ptr;

  ChrLoc *chrloc = (ChrLoc *) key;

  int tdepth = 0;

  float *af = (float *) malloc(sizeof(float)*4);
  for(int i=0; i<4; i++) af[i] = 0.0;

  char *value;
  uint64_t nvalues_total;
  CHECK_FOR_BLOCKS(multivalue,valuebytes,nvalues,nvalues_total)
  BEGIN_BLOCK_LOOP(multivalue,valuebytes,nvalues)

  value = multivalue;
  for(int i=0; i<nvalues; i++) {

    Depth *depth = (Depth *) value;
    tdepth += depth->d0;
    tdepth += depth->d1;
    tdepth += depth->d2;
    tdepth += depth->d3;

    af[0] += (float)depth->d0;
    af[1] += (float)depth->d1;
    af[2] += (float)depth->d2;
    af[3] += (float)depth->d3;

    value += valuebytes[i];
  }

 END_BLOCK_LOOP

 float f = log(data->error_rate) / (-1 * tdepth);

 int *index = (int *) malloc( sizeof(int) * 4 );

 for(int i=0; i<4; i++) {
     index[i] = 0;
     if((af[i]/(float)tdepth) > f) index[i] = 1;  
 } 

 kv->add((char *) &chrloc->loc, sizeof(int), (char *) index, sizeof(int)*4 );

 free(index); 

}



void reduce_call_SNV(char *key, int keybytes, char *multivalue, int nvalues, int *valuebytes, KeyValue *kv, void *ptr)
{
  Data *data = (Data *) ptr;

  ChrLoc *chrloc = (ChrLoc *) key;

  int tdepth = 0;

  float *af = (float *) malloc(sizeof(float)*4); 
  for(int i=0; i<4; i++) af[i] = 0.0;

  char *value;
  uint64_t nvalues_total;
  CHECK_FOR_BLOCKS(multivalue,valuebytes,nvalues,nvalues_total)
  BEGIN_BLOCK_LOOP(multivalue,valuebytes,nvalues)

  value = multivalue;
  for(int i=0; i<nvalues; i++) {

    Depth *depth = (Depth *) value;	
    tdepth += depth->d0;
    tdepth += depth->d1;
    tdepth += depth->d2; 
    tdepth += depth->d3;

    af[0] += (float)depth->d0;
    af[1] += (float)depth->d1;
    af[2] += (float)depth->d2;
    af[3] += (float)depth->d3;  

    value += valuebytes[i];
  }

  END_BLOCK_LOOP

  float f = log(data->error_rate) / (-1 * tdepth);
  //for(int i=0; i<4; i++) af[i] = af[i] / (float)tdepth;

  bool snv_check = false;
  for(int i=0; i<4; i++) {
	if((i != chrloc->ref_allele) && ((af[i]/(float)tdepth) > f)) { snv_check = true; break; }
  }

  if(snv_check) {	
	OutSNV out;
	out.af0 = af[0];
	out.af1 = af[1];
	out.af2 = af[2];
	out.af3 = af[3];

	out.f = f;
	out.ref_allele = chrloc->ref_allele;
	out.tdepth = tdepth;	

	kv->add((char *) &chrloc->loc, sizeof(int), (char *) &out, sizeof(OutSNV) );
//	data->outFile << chrloc->chr << " " << chrloc->loc << " " << chrloc->ref_allele << " " << f << " " << af[0] << " " << af[1] << " " << af[2] << " " << af[3] << " " << tdepth << endl;
  }

  free(af);

}



void reduce_extract_AF(char *key, int keybytes, char *multivalue, int nvalues, int *valuebytes, KeyValue *kv, void *ptr)
{

  Data *data = (Data *) ptr;

  if(nvalues >= data->depth) {

      int LOC = 29416326;

      char *value;
      AlignInfo *alignInfo = (AlignInfo *) key;

//      if( (alignInfo->chr == 2) && ((LOC-alignInfo->loc) > 0) && ((LOC-alignInfo->loc) < 97) )  {
//	if( alignInfo->chr == data->chromosome )  {

  	int num_sp1 = 0;
  	int num_sp2 = 0;

  	string ref_sequence = data->reference_sequence[alignInfo->chr-1].substr(alignInfo->loc-1, data->range);
  	std::size_t len_consen = ref_sequence.length();

  	StripedSmithWaterman::Aligner aligner;
  	StripedSmithWaterman::Filter filter;
  	StripedSmithWaterman::Alignment alignment;

  	int32_t *bam_cigar = (int32_t *) malloc( sizeof(int32_t)*3 );

  	int *check_error   = (int *) malloc(sizeof(int)*4);
  	int *check_error_1 = (int *) malloc(sizeof(int)*4);
  	int *check_error_2 = (int *) malloc(sizeof(int)*4);

  	int *loc_consensus   = (int *) malloc( sizeof(int) * (len_consen+1)*2 );
  	int *num_consensus1  = (int *) malloc( sizeof(int) * (len_consen+1) * 4 * 2 );
  	int *num_consensus2  = (int *) malloc( sizeof(int) * (len_consen+1) * 4 * 2 );

        int *numCSEN  = (int *) malloc( sizeof(int) * (len_consen+1) * 4 * 2 );

        for(int k=0; k<(len_consen+1)*4*2; k++) numCSEN[k] = 0;

  	for(int k=0; k<3; k++) { check_error[k]= 0; check_error_1[k]= 0; check_error_2[k]= 0; }

  	for(int i=0; i<(len_consen+1)*2; i++)   loc_consensus[i]  = 0;
  	for(int i=0; i<(len_consen+1)*4*2; i++) num_consensus1[i] = 0;
  	for(int i=0; i<(len_consen+1)*4*2; i++) num_consensus2[i] = 0;

        int *READ   = (int *) malloc( sizeof(int) * ((len_consen + 1) * (nvalues + 1)) );
        for(int i=0; i<(nvalues+1); i++)
             for(int j=0; j<(len_consen+1); j++) READ[i*len_consen + j] = 0; 

  	string head_seq, seq, rev_seq;
  	uint64_t nvalues_total;
  	CHECK_FOR_BLOCKS(multivalue,valuebytes,nvalues,nvalues_total)
  	BEGIN_BLOCK_LOOP(multivalue,valuebytes,nvalues)
	
   	  value = multivalue;
   	  for(int i=0; i<nvalues; i++) {
       		head_seq.assign(value, valuebytes[i]);
       		std::size_t pos  = head_seq.find_first_of(" ");

     		if( pos != std::string::npos ) {
       			string tmp_string = head_seq.substr(pos+1,data->range);
       			seq.assign(tmp_string.c_str(), data->range);

       			tmp_string = revcomp( seq.c_str() );
       			rev_seq.assign( tmp_string.c_str(), data->range);

       			int PE_direction = 0;
       			int Strand = 0;
       			Get_DirectionStrand(head_seq.c_str(), &PE_direction, &Strand, ref_sequence.c_str(), data->range);

       			alignment.Clear();
       			bool if_aligned;
       			if(Strand == 1) {
                		aligner.Align(seq.c_str(), ref_sequence.c_str(), len_consen, filter, &alignment);
                		if_aligned = check_alignment(alignment, data->range, ref_sequence.length());
                		if(if_aligned) {
                   			get_consensus_withBound(alignment, seq, num_consensus1, seq.length(), ref_sequence.length());
                   			if( PE_direction == 1)     num_sp1++;
                   			else if(PE_direction == 2) num_sp2++;
                		}
       			} else if(Strand == 2) {
                		aligner.Align(rev_seq.c_str(), ref_sequence.c_str(), len_consen, filter, &alignment);
                		if_aligned = check_alignment(alignment, data->range, ref_sequence.length());
                		if(if_aligned) {
                   			get_consensus_withBound(alignment, rev_seq, num_consensus1, rev_seq.length(), ref_sequence.length());
                   			if(PE_direction == 1)      num_sp1++;
                   			else if(PE_direction == 2) num_sp2++;
                		}
       			}

     		}
       		value += valuebytes[i];
   	  }

	if((num_sp1+num_sp2) > 1) {

		string csequence = check_consensus_sequence_iDES( ref_sequence.c_str(), check_error, num_consensus1, num_consensus2, numCSEN, len_consen, num_sp1, num_sp2, loc_consensus);

		alignment.Clear();
	        aligner.Align(csequence.c_str(), data->reference_sequence[alignInfo->chr-1].substr(alignInfo->loc - 1, len_consen*2).c_str(), len_consen*2, filter, &alignment);

		int sp     = (int)alignment.query_begin;
            	int sp_loc = (int)alignment.ref_begin;

		Depth depth;
		ChrLoc chrloc;
		chrloc.chr = data->chromosome;

		for (std::vector<uint32_t>::iterator it = alignment.cigar.begin() ; it != alignment.cigar.end(); ++it) {
			convert_cigar2bam(*it, bam_cigar);	
			if( (bam_cigar[0] == 0) || (bam_cigar[0] == 7) || (bam_cigar[0] == 8) ) {
			
			     for(int k=0; k<(int)bam_cigar[1]; k++) {
				 depth.d0 = numCSEN[(sp+k)*4]; depth.d1 = numCSEN[(sp+k)*4+1]; depth.d2 = numCSEN[(sp+k)*4+2]; depth.d3 = numCSEN[(sp+k)*4+3];
				 chrloc.loc = alignInfo->loc + sp_loc + k;				
				 chrloc.ref_allele  = get_int_from_base( data->reference_sequence[alignInfo->chr-1].substr(alignInfo->loc - 1, len_consen*2).c_str()[sp_loc + k] );
				 kv->add((char *) &chrloc, sizeof(ChrLoc), (char *) &depth, sizeof(Depth));
			     }

                           sp     += (int)bam_cigar[1];
                           sp_loc += (int)bam_cigar[1];

                  	} else if( bam_cigar[0] == 2 )  {
			   sp_loc += (int)bam_cigar[1];
                  	} else if( bam_cigar[0] == 1) {

//			   for(int k=0; k<(int)bam_cigar[1]; k++) {
//				depth.d0 = numCSEN[(sp+k)*4]; depth.d1 = numCSEN[(sp+k)*4+1]; depth.d2 = numCSEN[(sp+k)*4+2]; depth.d3 = numCSEN[(sp+k)*4+3];
//                                chrloc.loc = alignInfo->loc + sp_loc + k;
//                                chrloc.ref_allele  = get_int_from_base( data->reference_sequence[alignInfo->chr-1].substr(alignInfo->loc - 1, len_consen*2).c_str()[sp_loc + k] );
//                                kv->add((char *) &chrloc, sizeof(ChrLoc), (char *) &depth, sizeof(Depth));
//			   } 

                           sp += (int)bam_cigar[1];
                  	}
             }

//                int af_loc = LOC - alignInfo->loc;
//                data->outFile << alignInfo->chr << " "
//                              << alignInfo->loc << " "
//                              << LOC << " "
//                              << ref_sequence.c_str()[af_loc] << " "
//                              << csequence.c_str()[af_loc] << " "
//                              << numCSEN[af_loc*4] << " "
//                              << numCSEN[af_loc*4+1] << " "
//                              << numCSEN[af_loc*4+2] << " "
//                              << numCSEN[af_loc*4+3] << endl;


	}



//		for(int k = 0; k < csequence.length(); k++) { 
	//	   int af_loc = alignInfo->loc + k - 1;
//		   int intBase_ref  = get_int_from_base( ref_sequence.c_str()[k] );
	//	   int intBase_csen = get_int_from_base( csequence.c_str()[k] );
//		   int totalDepth = numCSEN[af_loc*4] + numCSEN[af_loc*4+1] + numCSEN[af_loc*4+2] + numCSEN[af_loc*4+3];

//		   int av = 0;
//		   for(int j=0; j<4; j++) 
//			if(j != intBase_ref) av += numCSEN[k*4+j];
		 
/*
		   bool onSite = false;
		   for (std::vector<ExonLoc>::iterator it = data->_target_loc.begin() ; it != data->_target_loc.end(); ++it) {
			ExonLoc exon = *it;
			if( (exon.chr == data->chromosome) && ((alignInfo->loc+k) >= exon.loc1) && ((alignInfo->loc+k) <= exon.loc2) ) {
				onSite = true; break;
			}
		   }
*/

//		   if(av>0) { 
//		   if((av>0) && onSite) {
//			data->outFile << alignInfo->chr << " " << alignInfo->loc+k << " " << intBase_ref << " " << intBase_csen << " "
//				      << numCSEN[k*4]   << " " << numCSEN[k*4+1]   << " " << numCSEN[k*4+2] << " " << numCSEN[k*4+3] << endl; 

//			Depth depth;
//			depth.d0 = numCSEN[k*4]; depth.d1 = numCSEN[k*4+1]; depth.d2 = numCSEN[k*4+2]; depth.d3 = numCSEN[k*4+3];

//			ChrLoc chrloc;
//			chrloc.chr = data->chromosome;
//			chrloc.loc = alignInfo->loc+k;
//			chrloc.ref_allele = intBase_ref;

//			kv->add((char *) &chrloc, sizeof(ChrLoc), (char *) &depth, sizeof(Depth));
		  // } 

//		}

/*
		int af_loc = LOC - alignInfo->loc; 	
		
		data->outFile << alignInfo->chr << " " 
			      << alignInfo->loc << " " 
			      << LOC << " " 
			      << ref_sequence.c_str()[af_loc] << " " 
			      << csequence.c_str()[af_loc] << " " 
			      << numCSEN[af_loc*4] << " " 
			      << numCSEN[af_loc*4+1] << " " 
			      << numCSEN[af_loc*4+2] << " " 
			      << numCSEN[af_loc*4+3] << endl; 
*/


/*
       		string csequence = check_consensus_sequence( ref_sequence.substr(0,len_consen).c_str(), check_error, num_consensus1, num_consensus2, len_consen, num_sp1, num_sp2, loc_consensus);
		int idRead = 0;
		int intBase;

          	value = multivalue;
          	for(int i=0; i<nvalues; i++) {
                   head_seq.assign(value, valuebytes[i]);
                   std::size_t pos  = head_seq.find_first_of(" ");

                   if( pos != std::string::npos ) {

			int PE_direction = 0;
                        int Strand = 0;
			Get_DirectionStrand(head_seq.c_str(), &PE_direction, &Strand, csequence.c_str(), data->range);

                        string tmp_string = head_seq.substr(pos+1,data->range);
                        if(Strand == 1) seq.assign(tmp_string.c_str(), data->range);
			else {		 
                           string tstring = revcomp( tmp_string.c_str() );
                           seq.assign( tstring.c_str(), data->range);
			}

			int sloc = idRead * len_consen;

			alignment.Clear();
			aligner.Align(seq.c_str(), csequence.c_str(), len_consen, filter, &alignment);
			if( (alignment.ref_begin - alignment.query_begin) >= 0 ) {
				if( (int)alignment.query_begin>0 )  {
				    for(int k=0; k<(int)alignment.query_begin; k++) {
					intBase = get_int_from_base( seq.substr(0,(int)alignment.query_begin).c_str()[k] );
					if(intBase < 4) READ[   sloc + (int)(alignment.ref_begin - alignment.query_begin) + k ] = intBase + 1;
				    }
				}
			} else {

			       int ss = (int)(alignment.query_begin - alignment.ref_begin);
          		       if((int)alignment.ref_begin > 0) {

         		         for(int k=0; k<(int)alignment.ref_begin; k++) {
                                   intBase = get_int_from_base( seq.substr(ss,alignment.ref_begin).c_str()[k] );
                                   if(intBase < 4) READ[ sloc + k ] = intBase + 1;
			         }

			       }

		       }


		       int sp     = (int)alignment.query_begin;
       		       int sp_loc = (int)alignment.ref_begin;
		       for (std::vector<uint32_t>::iterator it = alignment.cigar.begin() ; it != alignment.cigar.end(); ++it) {
         		  convert_cigar2bam(*it, bam_cigar);

         		  if( (bam_cigar[0] == 0) || (bam_cigar[0] == 7) || (bam_cigar[0] == 8) ) {
                              for(int k=0; k<(int)bam_cigar[1]; k++) {
                                    intBase = get_int_from_base( seq.substr(sp,(int)bam_cigar[1]).c_str()[k] );
                                    if(intBase < 4) {
                                         if( (sloc + sp_loc + k) <= (len_consen * idRead) ) READ[ sloc + sp_loc + k ] = intBase + 1;
                                    }
                              }
         
                              sp     += (int)bam_cigar[1];
                              sp_loc += (int)bam_cigar[1];
                          } else if( bam_cigar[0] == 2 )  {
                                 sp_loc += (int)bam_cigar[1];
                          } else if( bam_cigar[0] == 1) {

                            //    for(int k=0; k<(int)bam_cigar[1]; k++) {
                            //           intBase = get_int_from_base( seq.substr(sp,(int)bam_cigar[1]).c_str()[k] );
                            //           if(intBase < 4) {
                            //               if( (sloc + sp_loc + k) <= (len_consen * idRead) ) 
                            //                  READ[   sloc + sp_loc + k ] = intBase + 1;
                            //           }
                            //    }

			       sp     += (int)bam_cigar[1];

			} 

		     }


                     if(bam_cigar[0] == 4) {
          		for(int k=0; k<(int)bam_cigar[1]; k++) {
                            intBase = get_int_from_base( seq.substr(sp,(int)bam_cigar[1]).c_str()[k] );
                            if(intBase < 4) {
                              if( (sloc + sp_loc + k) <= (len_consen * idRead) ) READ[   sloc + sp_loc + k ] = intBase + 1;
                            }
                       }
                    }

		     idRead++;
		  }

                  value += valuebytes[i];
              }

*/


//	}

  	END_BLOCK_LOOP

	free(bam_cigar);
	free(check_error);
	free(check_error_1);
	free(check_error_2);
	free(loc_consensus);
	free(num_consensus1);
	free(num_consensus2);
	free(READ);
	free(numCSEN);

      }

//  }

}

// ###############################################################################################################################
//   read clustering - noPairing
//

void reduce_consensus_clustering_noPairing(char *key, int keybytes, char *multivalue, int nvalues, int *valuebytes, KeyValue *kv, void *ptr)
{
  Data *data = (Data *) ptr;

  if(nvalues >= data->depth) {

  char *value;

  AlignInfo *alignInfo = (AlignInfo *) key;

//if( (alignInfo->chr >= 1) && (alignInfo->chr <= 20) ) {

  int num_sp1 = 0;
  int num_sp2 = 0;

  string ref_sequence = data->reference_sequence[alignInfo->chr-1].substr(alignInfo->loc-1, data->range); 
  std::size_t len_consen = ref_sequence.length();

  StripedSmithWaterman::Aligner aligner;
  StripedSmithWaterman::Filter filter;
  StripedSmithWaterman::Alignment alignment;

  int32_t *bam_cigar = (int32_t *) malloc( sizeof(int32_t)*3 );

  int *check_error   = (int *) malloc(sizeof(int)*4);
  int *check_error_1 = (int *) malloc(sizeof(int)*4);
  int *check_error_2 = (int *) malloc(sizeof(int)*4);

  int *loc_consensus   = (int *) malloc( sizeof(int) * (len_consen+1)*2 );
  int *num_consensus1  = (int *) malloc( sizeof(int) * (len_consen+1) * 4 * 2 );
  int *num_consensus2  = (int *) malloc( sizeof(int) * (len_consen+1) * 4 * 2 );

  for(int k=0; k<3; k++) { check_error[k]= 0; check_error_1[k]= 0; check_error_2[k]= 0; }

  for(int i=0; i<(len_consen+1)*2; i++)   loc_consensus[i] = 0;
  for(int i=0; i<(len_consen+1)*4*2; i++) num_consensus1[i] = 0;
  for(int i=0; i<(len_consen+1)*4*2; i++) num_consensus2[i] = 0;

  string head_seq, seq, rev_seq;
  uint64_t nvalues_total;
  CHECK_FOR_BLOCKS(multivalue,valuebytes,nvalues,nvalues_total)
  BEGIN_BLOCK_LOOP(multivalue,valuebytes,nvalues)

   value = multivalue;
   for(int i=0; i<nvalues; i++) {
       head_seq.assign(value, valuebytes[i]);
       std::size_t pos  = head_seq.find_first_of(" ");

     if((pos != std::string::npos) && (valuebytes[i] > (data->range*2)) ) {  
       string tmp_string = head_seq.substr(pos+1,data->range);
       seq.assign(tmp_string.c_str(), data->range);

       tmp_string = revcomp( seq.c_str() );
       rev_seq.assign( tmp_string.c_str(), data->range);

       int PE_direction = 0;
       int Strand = 0;
       Get_DirectionStrand(head_seq.c_str(), &PE_direction, &Strand, ref_sequence.c_str(), data->range);	

       alignment.Clear();
       bool if_aligned;
       if(Strand == 1) {
		aligner.Align(seq.c_str(), ref_sequence.c_str(), len_consen, filter, &alignment);
                if_aligned = check_alignment(alignment, data->range, ref_sequence.length());	
		if(if_aligned) {
		   get_consensus_withBound(alignment, seq, num_consensus1, seq.length(), ref_sequence.length());
		   if( PE_direction == 1)     num_sp1++;
		   else if(PE_direction == 2) num_sp2++; 
		}
       } else if(Strand == 2) {
		aligner.Align(rev_seq.c_str(), ref_sequence.c_str(), len_consen, filter, &alignment);
		if_aligned = check_alignment(alignment, data->range, ref_sequence.length()); 		
		if(if_aligned) {
		   get_consensus_withBound(alignment, rev_seq, num_consensus1, rev_seq.length(), ref_sequence.length()); 
		   if(PE_direction == 1)      num_sp1++; 
                   else if(PE_direction == 2) num_sp2++; 
		}
       }

     }
       value += valuebytes[i];
   }

    if((num_sp1+num_sp2) >= data->depth) {

       string csequence = check_consensus_sequence( ref_sequence.substr(0,len_consen).c_str(), check_error, num_consensus1, num_consensus2, len_consen, num_sp1, num_sp2, loc_consensus); 
       data->outFile << ">chr:" << alignInfo->chr << " " << alignInfo->loc << " " << len_consen << " " << nvalues << endl;
//	fprintf(data->pFile, "%s%d%c%d%c%d%c%d\n", ">chr:", alignInfo->chr, ' ', alignInfo->loc, ' ', len_consen, ' ', nvalues );

       int idRead = 0;

       if(num_sp1 > 0) {

	print_clusteredReads_noPairing(&idRead, csequence.c_str(),len_consen,num_sp1, multivalue, nvalues, valuebytes, data->range,data->outFile, data->ftype,1,bam_cigar );


//    	  int *READ_1   = (int *) malloc( sizeof(int) * ((len_consen + 1) * (num_sp1 + 1)) );
//    	  int *Qvalue_1 = (int *) malloc( sizeof(int) * ((len_consen + 1) * (num_sp1 + 1)) );

//    	  for(int i=0; i<(num_sp1+1); i++)
//             for(int j=0; j<(len_consen+1); j++) { READ_1[i*len_consen + j] = 0; Qvalue_1[i*len_consen + j] = 0; }

//	  print_clusteredReads_noPairing(&idRead, csequence.c_str(),len_consen,num_sp1, alignment, filter,
//          			         multivalue, nvalues, valuebytes, data->range,data->outFile, data->ftype,1,1);

//	  print_clusteredReads_noPairing(&idRead, csequence.c_str(),len_consen,num_sp1, alignment, filter,
//                                         multivalue, nvalues, valuebytes, data->range,data->outFile, data->ftype,1,2);

//	  free(READ_1);
//	  free(Qvalue_1);
      }

      if(num_sp2 > 0) {

//	fprintf(data->pFile, "\n");
	print_clusteredReads_noPairing(&idRead, csequence.c_str(),len_consen,num_sp1, multivalue, nvalues, valuebytes, data->range,data->outFile, data->ftype,2,bam_cigar );


//	  data->outFile << endl;

//          int *READ_2   = (int *) malloc( sizeof(int) * ((len_consen + 1) * (num_sp2 + 1)) );
//          int *Qvalue_2 = (int *) malloc( sizeof(int) * ((len_consen + 1) * (num_sp2 + 1)) );

//          for(int i=0; i<(num_sp2+1); i++)
//             for(int j=0; j<(len_consen+1); j++) { READ_2[i*len_consen + j] = 0; Qvalue_2[i*len_consen + j] = 0; }

//          print_clusteredReads_noPairing(&idRead, csequence.c_str(),len_consen,num_sp1, alignment, filter,
//                                         multivalue, nvalues, valuebytes, data->range,data->outFile, data->ftype,2,1);

//          print_clusteredReads_noPairing(&idRead, csequence.c_str(),len_consen,num_sp1, alignment, filter,
//                                         multivalue, nvalues, valuebytes, data->range,data->outFile, data->ftype,2,2);

//          free(READ_2);
//          free(Qvalue_2);
      }


/*

        int sloc, sp, sp_loc;
        int32_t *bam_cigar = (int32_t *) malloc( sizeof(int32_t)*3 );
        value = multivalue;
        for(int i=0; i<nvalues; i++) {
           head_seq.assign(value, valuebytes[i]);
           std::size_t pos    = head_seq.find_first_of(" ");

           if(pos != std::string::npos ) {

             int PE_direction = 0;
             int Strand = 0;
             Get_DirectionStrand(head_seq.c_str(), &PE_direction, &Strand, csequence.substr(0,len_consen).c_str(), data->range);

             if( (PE_direction == 1) && (Strand == 1) && (num_sp1 > 0) ) {

          	stringstream ss_out;
          	ss_out.str(std::string());

          	string quality, seq;

          	seq.assign( head_seq.substr(pos+1,data->range).c_str(), data->range );
          	if(data->ftype) quality.assign(head_seq.substr(pos + data->range + 2, data->range).c_str(), data->range);

          	sloc = idRead * len_consen;

          	alignment.Clear();
          	aligner.Align(seq.c_str(), csequence.c_str(), len_consen, filter, &alignment);

          	if( (alignment.ref_begin - alignment.query_begin) >= 0 ) {
               	  for(int j=0; j<abs( (int)(alignment.ref_begin-alignment.query_begin) ); j++) ss_out << " ";
                  if( (int)alignment.query_begin>0 )  ss_out << seq.substr(0,(int)alignment.query_begin).c_str();
                  } else {
                     int ss = (int)(alignment.query_begin - alignment.ref_begin);
                     if((int)alignment.ref_begin > 0) ss_out << seq.substr(ss,(int)alignment.ref_begin).c_str();
                 }

                 sp     = (int)alignment.query_begin;
                 sp_loc = (int)alignment.ref_begin;
                 for(size_t j = 0; j < alignment.cigar.size(); j++)  {
                    convert_cigar2bam(alignment.cigar[j], bam_cigar);

                    if( (bam_cigar[0] == 0) || (bam_cigar[0] == 7) || (bam_cigar[0] == 8) ) {
                           ss_out << seq.substr(sp,(int)bam_cigar[1]).c_str();
                           sp     += (int)bam_cigar[1];
                           sp_loc += (int)bam_cigar[1];

                    } else if( bam_cigar[0] == 2 )  {
                           for(int k=0; k<(int)bam_cigar[1]; k++) ss_out << "-";
                           sp_loc += (int)bam_cigar[1];
                    } else if( bam_cigar[0] == 1) {
                            sp     += (int)bam_cigar[1];
                   }
               }
               if(bam_cigar[0] == 4) ss_out << seq.substr(sp,(int)bam_cigar[1]).c_str();
               ss_out << " --- " << head_seq.substr(0,pos).c_str() << " " << Strand;

               data->outFile << ss_out.str().c_str() << endl;
               idRead++;

             }

           }

           value += valuebytes[i];
        }


        value = multivalue;
        for(int i=0; i<nvalues; i++) {
           head_seq.assign(value, valuebytes[i]);
           std::size_t pos    = head_seq.find_first_of(" ");

           if(pos != std::string::npos ) {

             int PE_direction = 0;
             int Strand = 0;
             Get_DirectionStrand(head_seq.c_str(), &PE_direction, &Strand, csequence.substr(0,len_consen).c_str(), data->range);

             if( (PE_direction == 1) && (Strand == 2) && (num_sp1 > 0) ) {

                stringstream ss_out;
                ss_out.str(std::string());

                string quality, seq;

                seq.assign( head_seq.substr(pos+1,data->range).c_str(), data->range );
		string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

                if(data->ftype) quality.assign(head_seq.substr(pos + data->range + 2, data->range).c_str(), data->range);

                sloc = idRead * len_consen;

                alignment.Clear();
                aligner.Align(rev_seq.c_str(),     csequence.c_str(), len_consen, filter, &alignment);

                if( (alignment.ref_begin - alignment.query_begin) >= 0 ) {
                  for(int j=0; j<abs( (int)(alignment.ref_begin-alignment.query_begin) ); j++) ss_out << " ";
                  if( (int)alignment.query_begin>0 )  ss_out << rev_seq.substr(0,(int)alignment.query_begin).c_str();
                  } else {
                     int ss = (int)(alignment.query_begin - alignment.ref_begin);
                     if((int)alignment.ref_begin > 0) ss_out << rev_seq.substr(ss,(int)alignment.ref_begin).c_str();
                 }

                 sp     = (int)alignment.query_begin;
                 sp_loc = (int)alignment.ref_begin;
                 for(size_t j = 0; j < alignment.cigar.size(); j++)  {
                    convert_cigar2bam(alignment.cigar[j], bam_cigar);

                    if( (bam_cigar[0] == 0) || (bam_cigar[0] == 7) || (bam_cigar[0] == 8) ) {
                           ss_out << rev_seq.substr(sp,(int)bam_cigar[1]).c_str();
                           sp     += (int)bam_cigar[1];
                           sp_loc += (int)bam_cigar[1];

                    } else if( bam_cigar[0] == 2 )  {
                           for(int k=0; k<(int)bam_cigar[1]; k++) ss_out << "-";
                           sp_loc += (int)bam_cigar[1];
                    } else if( bam_cigar[0] == 1) {
                            sp     += (int)bam_cigar[1];
                   }
               }
               if(bam_cigar[0] == 4) ss_out << rev_seq.substr(sp,(int)bam_cigar[1]).c_str();
               ss_out << " --- " << head_seq.substr(0,pos).c_str() << " " << Strand;

               data->outFile << ss_out.str().c_str() << endl;
               idRead++;

             }

           }

           value += valuebytes[i];
        }


        value = multivalue;
        for(int i=0; i<nvalues; i++) {
           head_seq.assign(value, valuebytes[i]);
           std::size_t pos    = head_seq.find_first_of(" ");

           if(pos != std::string::npos ) {

             int PE_direction = 0;
             int Strand = 0;
             Get_DirectionStrand(head_seq.c_str(), &PE_direction, &Strand, csequence.substr(0,len_consen).c_str(), data->range);

             if( (PE_direction == 2) && (Strand == 1) && (num_sp2 > 0) ) {

                stringstream ss_out;
                ss_out.str(std::string());

                string quality, seq;

                seq.assign( head_seq.substr(pos+1,data->range).c_str(), data->range );
                if(data->ftype) quality.assign(head_seq.substr(pos + data->range + 2, data->range).c_str(), data->range);

                sloc = idRead * len_consen;

                alignment.Clear();
                aligner.Align(seq.c_str(),     csequence.c_str(), len_consen, filter, &alignment);

                if( (alignment.ref_begin - alignment.query_begin) >= 0 ) {
                  for(int j=0; j<abs( (int)(alignment.ref_begin-alignment.query_begin) ); j++) ss_out << " ";
                  if( (int)alignment.query_begin>0 )  ss_out << seq.substr(0,(int)alignment.query_begin).c_str();
                  } else {
                     int ss = (int)(alignment.query_begin - alignment.ref_begin);
                     if((int)alignment.ref_begin > 0) ss_out << seq.substr(ss,(int)alignment.ref_begin).c_str();
                 }

                 sp     = (int)alignment.query_begin;
                 sp_loc = (int)alignment.ref_begin;
                 for(size_t j = 0; j < alignment.cigar.size(); j++)  {
                    convert_cigar2bam(alignment.cigar[j], bam_cigar);

                    if( (bam_cigar[0] == 0) || (bam_cigar[0] == 7) || (bam_cigar[0] == 8) ) {
                           ss_out << seq.substr(sp,(int)bam_cigar[1]).c_str();
                           sp     += (int)bam_cigar[1];
                           sp_loc += (int)bam_cigar[1];

                    } else if( bam_cigar[0] == 2 )  {
                           for(int k=0; k<(int)bam_cigar[1]; k++) ss_out << "-";
                           sp_loc += (int)bam_cigar[1];
                    } else if( bam_cigar[0] == 1) {
                            sp     += (int)bam_cigar[1];
                   }
               }
               if(bam_cigar[0] == 4) ss_out << seq.substr(sp,(int)bam_cigar[1]).c_str();
               ss_out << " --- " << head_seq.substr(0,pos).c_str() << " " << Strand;

               data->outFile << ss_out.str().c_str() << endl;
               idRead++;

             }

           }

           value += valuebytes[i];
        }

	value = multivalue;
        for(int i=0; i<nvalues; i++) {
           head_seq.assign(value, valuebytes[i]);
           std::size_t pos    = head_seq.find_first_of(" ");

           if(pos != std::string::npos ) {

             int PE_direction = 0;
             int Strand = 0;
             Get_DirectionStrand(head_seq.c_str(), &PE_direction, &Strand, csequence.substr(0,len_consen).c_str(), data->range);

             if( (PE_direction == 2) && (Strand == 2) && (num_sp2 > 0) ) {

                stringstream ss_out;
                ss_out.str(std::string());

                string quality, seq;

                seq.assign( head_seq.substr(pos+1,data->range).c_str(), data->range );
	        string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

                if(data->ftype) quality.assign(head_seq.substr(pos + data->range + 2, data->range).c_str(), data->range);

                sloc = idRead * len_consen;

                alignment.Clear();
                aligner.Align(rev_seq.c_str(),     csequence.c_str(), len_consen, filter, &alignment);

                if( (alignment.ref_begin - alignment.query_begin) >= 0 ) {
                  for(int j=0; j<abs( (int)(alignment.ref_begin-alignment.query_begin) ); j++) ss_out << " ";
                  if( (int)alignment.query_begin>0 )  ss_out << rev_seq.substr(0,(int)alignment.query_begin).c_str();
                  } else {
                     int ss = (int)(alignment.query_begin - alignment.ref_begin);
                     if((int)alignment.ref_begin > 0) ss_out << rev_seq.substr(ss,(int)alignment.ref_begin).c_str();
                 }

                 sp     = (int)alignment.query_begin;
                 sp_loc = (int)alignment.ref_begin;
                 for(size_t j = 0; j < alignment.cigar.size(); j++)  {
                    convert_cigar2bam(alignment.cigar[j], bam_cigar);

                    if( (bam_cigar[0] == 0) || (bam_cigar[0] == 7) || (bam_cigar[0] == 8) ) {
                           ss_out << rev_seq.substr(sp,(int)bam_cigar[1]).c_str();
                           sp     += (int)bam_cigar[1];
                           sp_loc += (int)bam_cigar[1];

                    } else if( bam_cigar[0] == 2 )  {
                           for(int k=0; k<(int)bam_cigar[1]; k++) ss_out << "-";
                           sp_loc += (int)bam_cigar[1];
                    } else if( bam_cigar[0] == 1) {
                            sp     += (int)bam_cigar[1];
                   }
               }
               if(bam_cigar[0] == 4) ss_out << rev_seq.substr(sp,(int)bam_cigar[1]).c_str();
               ss_out << " --- " << head_seq.substr(0,pos).c_str() << " " << Strand;

               data->outFile << ss_out.str().c_str() << endl;
               idRead++;

             }

           }

           value += valuebytes[i];
        }

        free(bam_cigar);
*/


       stringstream tmpOUT;
       tmpOUT.str(std::string());
       for(int j=0; j<len_consen; j++) {
          if     (loc_consensus[j] == 1)  tmpOUT << "|"; //data->outFile << "|";  fprintf(data->pFile, "%c", '|'); //tmpOUT << "|"; //data->outFile << "|";
          else if(loc_consensus[j] == 2)  tmpOUT << ":"; //fprintf(data->pFile, "%c", ':'); //tmpOUT << ":"; //data->outFile << ":";
          else                            tmpOUT << " "; //fprintf(data->pFile, "%c", ' '); //tmpOUT << " "; //data->outFile << " ";
       }
//       fprintf(data->pFile, "\n");
       tmpOUT << endl;
//       data->outFile << tmpOUT.str().c_str() << endl;

//       data->outFile << ref_sequence.substr(0,ref_sequence.length()).c_str() << endl;
//       data->outFile << csequence.substr(0,csequence.length()).c_str() << endl;

//	 fprintf(data->pFile, "%s\n", ref_sequence.substr(0,ref_sequence.length()).c_str() );
//	 fprintf(data->pFile, "%s\n", csequence.substr(0,csequence.length()).c_str() );

       tmpOUT << ref_sequence.substr(0,ref_sequence.length()).c_str() << endl;
       tmpOUT << csequence.substr(0,csequence.length()).c_str() << endl;

       tmpOUT << "ID::: chr:" << alignInfo->chr << " " << alignInfo->loc;
       tmpOUT << " SIZE: " << nvalues << " "  << num_sp1+num_sp2 << " " << idRead << " " << num_sp1 << " " << num_sp2;
       tmpOUT << " " << check_error[0] << " " << check_error[1] << " " << check_error[2] << " " << len_consen << endl << endl;

       data->outFile << tmpOUT.str().c_str();

//	 fprintf(data->pFile, "%s%d%c%d", "ID::: chr:", alignInfo->chr, ' ', alignInfo->loc);
//	 fprintf(data->pFile, "%s%d%c%d%c%d%c%d%c%d", " SIZE: ", nvalues, ' ', num_sp1+num_sp2, ' ', idRead, ' ', num_sp1, ' ', num_sp2);
//	 fprintf(data->pFile, "%c%d%c%d%c%d%c%d\n\n", ' ', check_error[0], ' ', check_error[1], ' ', check_error[2], ' ', len_consen );

  }


  END_BLOCK_LOOP

  free(check_error);
  free(check_error_1);
  free(check_error_2);

  free(loc_consensus);
  free(num_consensus1);
  free(num_consensus2);

  free(bam_cigar);

//}

  }
}

// ###############################################################################################################################
//
//    Read Clustering with p-values
//

void reduce_consensus_clustering(char *key, int keybytes, char *multivalue, int nvalues, int *valuebytes, KeyValue *kv, void *ptr)
{
  Data *data = (Data *) ptr;
  char *value;

  PairID LinkID = *(PairID *) key;

  int num_sp1 = 0;
  int num_sp2 = 0;

  std::size_t  len_consen_1, len_consen_2;

  bool overlap = false;
  int offset;
  if(LinkID.loc1 <= LinkID.loc2) offset = LinkID.loc1 + data->range - 1 - LinkID.loc2;
  else                           offset = LinkID.loc2 + data->range - 1 - LinkID.loc1;
  if( offset >= data->OVERLAP ) overlap = true;

  string ref_sequence_1, ref_sequence_2;

if(data->On_Alignment) {
  if(overlap) {
        if(LinkID.loc1 <= LinkID.loc2) ref_sequence_1 = data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc1, LinkID.loc2-LinkID.loc1+data->range-1);
        else                           ref_sequence_1 = data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc2, LinkID.loc1-LinkID.loc2+data->range-1);
  } else {
        ref_sequence_1 = data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc1, data->range);
        ref_sequence_2 = data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc2, data->range);
  }
}

  IRKE irke_1(data->kmer_length, data->MAX_RECURSION, data->MIN_SEED_ENTROPY, data->MIN_SEED_COVERAGE,
             data->min_any_entropy, data->PACMAN, data->CRAWL, data->crawl_length, data->DS);

  IRKE irke_2(data->kmer_length, data->MAX_RECURSION, data->MIN_SEED_ENTROPY, data->MIN_SEED_COVERAGE,
             data->min_any_entropy, data->PACMAN, data->CRAWL, data->crawl_length, data->DS);

  StripedSmithWaterman::Aligner aligner;
  StripedSmithWaterman::Filter filter;
  StripedSmithWaterman::Alignment alignment;

  uint64_t nvalues_total;
  CHECK_FOR_BLOCKS(multivalue,valuebytes,nvalues,nvalues_total)
  BEGIN_BLOCK_LOOP(multivalue,valuebytes,nvalues)

if(data->On_Assemble) {

   value = multivalue;
   for(int i=0; i<nvalues; i++) {
     string head_seq(value);
     std::size_t pos = head_seq.find_first_of(" ");

     int PE_direction = 0;
     std::size_t pe_pos = head_seq.find_first_of("_");
     if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
     if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

     string seq(head_seq.substr(pos+1,data->range).c_str() );
     string rev_seq = revcomp( seq.substr(0,data->range) );

     int nKmer = data->range - data->kmer_length + 1;
     for(int j=0; j<nKmer; j++) {

        string seq_kmer = seq.substr(j, data->kmer_length);

        if( contains_non_gatc(seq_kmer) ) {
            uint64_t kmer_val = kmer_to_intval(seq_kmer);
            uint64_t rkmer_val = revcomp_val(kmer_val, data->kmer_length);

            if(overlap) {
                irke_1.add_kmer(kmer_val , 1);
                irke_1.add_kmer(rkmer_val , 1);
            } else if(PE_direction == 1) {
                irke_1.add_kmer(kmer_val , 1);
                irke_1.add_kmer(rkmer_val , 1);
            } else {
                irke_2.add_kmer(kmer_val , 1);
                irke_2.add_kmer(rkmer_val , 1);
            }

        }

     }

     value += valuebytes[i];
   }

    irke_1.prune_some_kmers(data->min_kmer_count, data->min_any_entropy, data->prune_error_kmers, data->min_ratio_non_error);
    irke_1.populate_sorted_kmers_list();

    ref_sequence_1 =
        irke_1.compute_sequence_assemblies( data->MIN_CONNECTIVITY_RATIO, data->MIN_ASSEMBLY_LENGTH, data->MIN_ASSEMBLY_COVERAGE );

    if(!overlap) {
      irke_2.prune_some_kmers(data->min_kmer_count, data->min_any_entropy, data->prune_error_kmers, data->min_ratio_non_error);
      irke_2.populate_sorted_kmers_list();
      ref_sequence_2 =
        irke_2.compute_sequence_assemblies( data->MIN_CONNECTIVITY_RATIO, data->MIN_ASSEMBLY_LENGTH, data->MIN_ASSEMBLY_COVERAGE );
    }

}

  int *check_error   = (int *) malloc(sizeof(int)*4);
  int *check_error_1 = (int *) malloc(sizeof(int)*4);
  int *check_error_2 = (int *) malloc(sizeof(int)*4);

  len_consen_1 = ref_sequence_1.size();
  if(!overlap) len_consen_2 = ref_sequence_2.size();

  int *loc_consensus_1  = (int *) malloc( sizeof(int) * (len_consen_1+1)*2 );
  int *loc_consensus_2;
  if(!overlap) loc_consensus_2 = (int *) malloc( sizeof(int) * (len_consen_2+1)*2 );

  int *num_consensus1 = (int *) malloc( sizeof(int) * (len_consen_1+1) * 4 * 2 );
  int *num_consensus2;

  if(overlap) num_consensus2 = (int *) malloc( sizeof(int) * (len_consen_1+1) * 4 * 2 );
  else        num_consensus2 = (int *) malloc( sizeof(int) * (len_consen_2+1) * 4 * 2 );

  for(int i=0; i<(len_consen_1+1)*2; i++) loc_consensus_1[i] = 0;
  if(!overlap)
    for(int i=0; i<(len_consen_2+1)*2; i++) loc_consensus_2[i] = 0;

  for(int i=0; i<(len_consen_1+1)*4*2; i++) num_consensus1[i] = 0;
  if(overlap) {
        for(int i=0; i<(len_consen_1+1)*4*2; i++) num_consensus2[i] = 0;
  } else {
        for(int i=0; i<(len_consen_2+1)*4*2; i++) num_consensus2[i] = 0;
  }

  data->outFile << ">chr:" << LinkID.chr1 << " " << offset << " " << LinkID.loc1 << " " << LinkID.loc2 << " " << len_consen_1 << " " << nvalues << endl;

  string csequence_1, csequence_2;

  if( (overlap && (len_consen_1 >= data->range) && (nvalues >= 6)) || (!overlap && (len_consen_1 >= data->range) && (len_consen_2 >= data->range) && (nvalues >= 6)) ) {

    value = multivalue;
    for(int i=0; i<nvalues; i++) {
       string head_seq(value);
       std::size_t pos    = head_seq.find_first_of(" ");

       int PE_direction = 0;
       std::size_t pe_pos = head_seq.find_first_of("_");
       if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
       if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

       string seq( head_seq.substr(pos+1,data->range).c_str() );
       string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

       if(PE_direction == 1) {

         int Strand = 0;
         Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_1, data->range);

         alignment.Clear();

         if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_1.c_str(), len_consen_1, filter, &alignment);
         else            aligner.Align(rev_seq.c_str(), ref_sequence_1.c_str(), len_consen_1, filter, &alignment);

         if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus1);
         else            get_consensus(alignment, rev_seq.c_str(), num_consensus1);

         num_sp1++;
       }

       if(PE_direction == 2) {

        int Strand = 0;
        if(overlap) Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_1, data->range);
        else        Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_2, data->range);


        alignment.Clear();
        if(overlap) {
                if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_1.c_str(), len_consen_1, filter, &alignment);
                else            aligner.Align(rev_seq.c_str(), ref_sequence_1.c_str(), len_consen_1, filter, &alignment);

                if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus2);
                else            get_consensus(alignment, rev_seq.c_str(), num_consensus2);

        } else {
                if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_2.c_str(), len_consen_2, filter, &alignment);
                else            aligner.Align(rev_seq.c_str(), ref_sequence_2.c_str(), len_consen_2, filter, &alignment);

                if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus2);
                else            get_consensus(alignment, rev_seq.c_str(), num_consensus2);
        }

        num_sp2++;
      }

      value += valuebytes[i];
    }

   int num_deletion_1 = 0;
   int num_deletion_2 = 0;

if(data->On_Alignment) {

   if(overlap) {
        num_deletion_1 = check_deletion_consensus(num_consensus1, num_consensus2, len_consen_1, num_sp1, num_sp2);
   } else {
        num_deletion_1 = check_deletion_consensus_single(num_consensus1, len_consen_1, num_sp1);
        num_deletion_2 = check_deletion_consensus_single(num_consensus2, len_consen_2, num_sp2);
   }

   if( overlap && (num_deletion_1 > 0) ) {

        if(LinkID.loc1 <= LinkID.loc2) ref_sequence_1.assign( data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc1, LinkID.loc2-LinkID.loc1+data->range-1 + num_deletion_1) );
        else                           ref_sequence_1.assign( data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc2, LinkID.loc1-LinkID.loc2+data->range-1 + num_deletion_1) );
        len_consen_1 = ref_sequence_1.size();

        free(loc_consensus_1);
        free(num_consensus1);
        loc_consensus_1 = (int *) malloc( sizeof(int) * (len_consen_1+1) * 2 );
        num_consensus1  = (int *) malloc( sizeof(int) * (len_consen_1+1) * 4 * 2 );

        for(int i=0; i<(len_consen_1+1)*2; i++)   loc_consensus_1[i] = 0;
        for(int i=0; i<(len_consen_1+1)*4*2; i++) num_consensus1[i] = 0;
        for(int i=0; i<(len_consen_1+1)*4*2; i++) num_consensus2[i] = 0;

        value = multivalue;
        for(int i=0; i<nvalues; i++) {
           string head_seq(value);
           std::size_t pos    = head_seq.find_first_of(" ");

           int PE_direction = 0;
           std::size_t pe_pos = head_seq.find_first_of("_");
           if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
           if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

           int Strand = 0;
           Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_1, data->range);

           string seq( head_seq.substr(pos+1,data->range).c_str() );
           string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

           alignment.Clear();
           if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_1.c_str(), len_consen_1, filter, &alignment);
           else            aligner.Align(rev_seq.c_str(), ref_sequence_1.c_str(), len_consen_1, filter, &alignment);


           if(PE_direction == 1) {

             if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus1);
             else            get_consensus(alignment, rev_seq.c_str(), num_consensus1);
           }

           if(PE_direction == 2) {

             if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus2);
             else            get_consensus(alignment, rev_seq.c_str(), num_consensus2);

           }

           value += valuebytes[i];
       }
   }

   if( !overlap && (num_deletion_1 > 0) ) {

        ref_sequence_1.assign( data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc1, data->range + num_deletion_1) );
        len_consen_1 = ref_sequence_1.size();

        free(loc_consensus_1);
        free(num_consensus1);
        loc_consensus_1 = (int *) malloc( sizeof(int) * (len_consen_1+1)*2 );
        num_consensus1  = (int *) malloc( sizeof(int) * (len_consen_1+1) * 4 * 2 );

        for(int i=0; i<len_consen_1*2; i++)   loc_consensus_1[i] = 0;
        for(int i=0; i<len_consen_1*4*2; i++) num_consensus1[i] = 0;

        value = multivalue;
        for(int i=0; i<nvalues; i++) {
           string head_seq(value);
           std::size_t pos    = head_seq.find_first_of(" ");

           int PE_direction = 0;
           std::size_t pe_pos = head_seq.find_first_of("_");
           if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
           if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

           if(PE_direction == 1) {
             int Strand = 0;
             Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_1, data->range);

             string seq( head_seq.substr(pos+1,data->range).c_str() );
             string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

             alignment.Clear();

             if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_1.c_str(), len_consen_1, filter, &alignment);
             else            aligner.Align(rev_seq.c_str(), ref_sequence_1.c_str(), len_consen_1, filter, &alignment);

             if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus1);
             else            get_consensus(alignment, rev_seq.c_str(), num_consensus1);
           }

           value += valuebytes[i];
       }
   }

   if( !overlap && (num_deletion_2 > 0) ) {

        ref_sequence_2.assign( data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc2, data->range + num_deletion_2) );
        len_consen_2 = ref_sequence_2.size();

        free(loc_consensus_2);
        free(num_consensus2);
        loc_consensus_2 = (int *) malloc( sizeof(int) * (len_consen_2+1)*2 );
        num_consensus2  = (int *) malloc( sizeof(int) * (len_consen_2+1) * 4 * 2 );

        for(int i=0; i<len_consen_2*2; i++)   loc_consensus_2[i] = 0;
        for(int i=0; i<len_consen_2*4*2; i++) num_consensus2[i] = 0;

        value = multivalue;
        for(int i=0; i<nvalues; i++) {
           string head_seq(value);
           std::size_t pos    = head_seq.find_first_of(" ");

           int PE_direction = 0;
           std::size_t pe_pos = head_seq.find_first_of("_");
           if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
           if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

           if(PE_direction == 2) {
             int Strand = 0;
             Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_2, data->range);

             string seq( head_seq.substr(pos+1,data->range).c_str() );
             string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

             alignment.Clear();

             if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_2.c_str(), len_consen_2, filter, &alignment);
             else            aligner.Align(rev_seq.c_str(), ref_sequence_2.c_str(), len_consen_2, filter, &alignment);

             if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus2);
             else            get_consensus(alignment, rev_seq.c_str(), num_consensus2);
           }

           value += valuebytes[i];
       }
   }

}


    for(int k=0; k<3; k++) { check_error[k]= 0; check_error_1[k]= 0; check_error_2[k]= 0; }
    if(overlap) { csequence_1 = check_consensus_sequence( ref_sequence_1.c_str(), check_error, num_consensus1, num_consensus2, len_consen_1, num_sp1, num_sp2, loc_consensus_1); }
    else        {
                  csequence_1 = check_consensus_seq_single( ref_sequence_1.c_str(), check_error_1, num_consensus1, len_consen_1, num_sp1, loc_consensus_1);
                  csequence_2 = check_consensus_seq_single( ref_sequence_2.c_str(), check_error_2, num_consensus2, len_consen_2, num_sp2, loc_consensus_2);
    }

    csequence_1 = csequence_1.substr(0,len_consen_1);
    if(!overlap) csequence_2 = csequence_2.substr(0,len_consen_2);

    vector<string> outName_1;
    vector<string> outName_2;

    map<string,int> outHeader_1;
    map<string,int> outHeader_2;

    map<string,int> index_read1;
    map<string,int> index_read2;

    int *READ_1, *READ_2, *Qvalue_1, *Qvalue_2;

    READ_1   = (int *) malloc( sizeof(int) * ((len_consen_1 + 1) * (num_sp1 + 1)) );
    Qvalue_1 = (int *) malloc( sizeof(int) * ((len_consen_1 + 1) * (num_sp1 + 1)) );

    if(overlap) {
      READ_2   = (int *) malloc( sizeof(int) * ((len_consen_1 + 1) * (num_sp2 + 1)) ); 
      Qvalue_2 = (int *) malloc( sizeof(int) * ((len_consen_1 + 1) * (num_sp2 + 1)) );  
    } else {
      READ_2   = (int *) malloc( sizeof(int) * ((len_consen_2 + 1) * (num_sp2 + 1)) );
      Qvalue_2 = (int *) malloc( sizeof(int) * ((len_consen_2 + 1) * (num_sp2 + 1)) ); 
    }

    for(int i=0; i<(num_sp1+1); i++) 
	   for(int j=0; j<(len_consen_1+1); j++) { READ_1[i*len_consen_1 + j] = 0; Qvalue_1[i*len_consen_1 + j] = 0; }

    if(overlap) {
      for(int i=0; i<(num_sp2+1); i++)
           for(int j=0; j<len_consen_1; j++) { READ_2[i*len_consen_1 + j] = 0; Qvalue_2[i*len_consen_1 + j] = 0; }
    } else {
      for(int i=0; i<(num_sp2+1); i++)
           for(int j=0; j<(len_consen_2+1); j++) { READ_2[i*len_consen_2 + j] = 0; Qvalue_2[i*len_consen_2 + j] = 0; }
    }

    int idRead = 0;
    value = multivalue;
    for(int i=0; i<nvalues; i++) {
       string head_seq(value);
       std::size_t pos    = head_seq.find_first_of(" ");

       int PE_direction = 0;
       std::size_t pe_pos = head_seq.find_first_of("_");
       if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
       if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

       if( (PE_direction == 1) && (outHeader_1.count(head_seq.substr(0,pe_pos)) <= 0) ) {

	 outName_1.push_back( head_seq.substr(0,pe_pos) );
	 outHeader_1[head_seq.substr(0,pe_pos)] = 1;
	 index_read1[head_seq.substr(0,pe_pos)] = idRead;

         int Strand = 0;
         Get_DirectionStrand(head_seq, &PE_direction, &Strand, csequence_1, data->range);

         string seq( head_seq.substr(pos+1,data->range).c_str() );
         string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

         string quality, rev_quality;
         if(data->ftype) {
         	std::size_t qos    = head_seq.find_first_of("@");
                quality.assign( head_seq.substr(qos+1,data->range).c_str(), data->range );
		rev_quality.assign( revquality( quality.substr(0,data->range) ).c_str(), data->range );
         }

         alignment.Clear();
         if(Strand == 1) aligner.Align(seq.c_str(),     csequence_1.c_str(), len_consen_1, filter, &alignment);
         else            aligner.Align(rev_seq.c_str(), csequence_1.c_str(), len_consen_1, filter, &alignment);

         if(Strand == 1) print_reads(data->outFile, alignment, seq,     quality,     READ_1, Qvalue_1, idRead, len_consen_1, num_sp1 );
         else            print_reads(data->outFile, alignment, rev_seq, rev_quality, READ_1, Qvalue_1, idRead, len_consen_1, num_sp1 );

         data->outFile << " --- " << head_seq.substr(0,pos).c_str() << " " << Strand << endl;
	 idRead++;
       }

      value += valuebytes[i];
    }

    if(!overlap) {

        for(int j=0; j<len_consen_1; j++) {
          if(loc_consensus_1[j] == 1)       data->outFile << ":";
          else                              data->outFile << " ";
        }
        data->outFile << endl ;

        data->outFile << ref_sequence_1.substr(0,ref_sequence_1.length()).c_str() << endl;
        data->outFile << csequence_1.substr(0,csequence_1.length()).c_str() << endl;
        data->outFile << "ID-1::: chr:" << LinkID.chr1 << " " << LinkID.loc1 << " " << LinkID.loc2;
        data->outFile << " SIZE: " << nvalues << " "  << num_sp1 << " " << check_error_1[0] << " " << check_error_1[1];
	data->outFile << " " << len_consen_1 << endl << endl;

    }
    data->outFile << endl;

    idRead = 0;
    value = multivalue;
    for(int i=0; i<nvalues; i++) {
      string head_seq(value);
      std::size_t pos = head_seq.find_first_of(" ");

      int PE_direction = 0;
      std::size_t pe_pos = head_seq.find_first_of("_");
      if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
      if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

      if((PE_direction == 2) && (outHeader_2.count(head_seq.substr(0,pe_pos)) <= 0)) {

         outName_2.push_back( head_seq.substr(0,pe_pos) );
         outHeader_2[head_seq.substr(0,pe_pos)] = 1;
         index_read2[head_seq.substr(0,pe_pos)] = idRead;

        int Strand = 0;
        if(overlap) Get_DirectionStrand(head_seq, &PE_direction, &Strand, csequence_1, data->range);
        else        Get_DirectionStrand(head_seq, &PE_direction, &Strand, csequence_2, data->range);

        string seq( head_seq.substr(pos+1,data->range).c_str() );
        string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

        string quality, rev_quality;
        if(data->ftype) {
                std::size_t qos    = head_seq.find_first_of("@");
                quality.assign( head_seq.substr(qos+1,data->range).c_str(), data->range );
		rev_quality.assign( revquality( quality.substr(0,data->range) ).c_str(), data->range );
        }

        alignment.Clear();
        if(overlap) {
                if(Strand == 1) aligner.Align(seq.c_str(),     csequence_1.c_str(), len_consen_1, filter, &alignment);
                else            aligner.Align(rev_seq.c_str(), csequence_1.c_str(), len_consen_1, filter, &alignment);
        } else {
                if(Strand == 1) aligner.Align(seq.c_str(),     csequence_2.c_str(), len_consen_2, filter, &alignment);
                else            aligner.Align(rev_seq.c_str(), csequence_2.c_str(), len_consen_2, filter, &alignment);
        }

        int32_t start_loc = -1;
        start_loc = alignment.ref_begin - alignment.query_begin;

	if(overlap) {
        	if(Strand == 1) print_reads(data->outFile, alignment, seq,     quality,     READ_2, Qvalue_2, idRead, len_consen_1, num_sp2);
        	else            print_reads(data->outFile, alignment, rev_seq, rev_quality, READ_2, Qvalue_2, idRead, len_consen_1, num_sp2);
	} else {
		if(Strand == 1) print_reads(data->outFile, alignment, seq,     quality,     READ_2, Qvalue_2, idRead, len_consen_2, num_sp2);
        	else            print_reads(data->outFile, alignment, rev_seq, rev_quality, READ_2, Qvalue_2, idRead, len_consen_2, num_sp2);
	}


        data->outFile << " --- " << head_seq.substr(0,pos).c_str() << " " << Strand << endl;

	idRead++;
      }

      value += valuebytes[i];
    }

    if(overlap) {
         for(int j=0; j<len_consen_1; j++) {
           if     (loc_consensus_1[j] == 1)  data->outFile << "|";
           else if(loc_consensus_1[j] == 2)  data->outFile << ":";
           else                              data->outFile << " ";
         }

         int *pcrOUT = (int *) malloc( sizeof(int) * 4 );

         Cal_pcrEfficiency(pcrOUT, len_consen_1, num_sp1, csequence_1, loc_consensus_1, READ_1, READ_2, Qvalue_1, Qvalue_2, 13);

         data->outFile << endl;
         data->outFile << ref_sequence_1.substr(0,ref_sequence_1.length()).c_str() << endl;
         data->outFile << csequence_1.substr(0,csequence_1.length()).c_str() << endl;

         data->outFile << "ID::: chr:" << LinkID.chr1 << " " << LinkID.loc1 << " " << LinkID.loc2;
         data->outFile << " SIZE: " << nvalues << " "  << num_sp1+num_sp2 << " " << num_sp1 << " " << num_sp2;
         data->outFile << " " << check_error[0] << " " << check_error[1] << " " << check_error[2] << " " << len_consen_1;
	 data->outFile << " " << pcrOUT[0] << " " << pcrOUT[1] << " " << pcrOUT[2] << " " << pcrOUT[3]<< endl << endl;

	 free(pcrOUT);

    } else {
          for(int j=0; j<len_consen_2; j++) {
            if(loc_consensus_2[j] == 1)       data->outFile << ":";
            else                              data->outFile << " ";
          }

         data->outFile << endl;
         data->outFile << ref_sequence_2.substr(0,ref_sequence_2.length()).c_str() << endl;
         data->outFile << csequence_2.substr(0,csequence_2.length()).c_str() << endl;
         data->outFile << "ID-2::: chr:" << LinkID.chr1 << " " << LinkID.loc1 << " " << LinkID.loc2;
         data->outFile << " SIZE: " << nvalues << " "  << num_sp2 << " " << check_error_2[0] << " " << check_error_2[1];
	 data->outFile << " " << len_consen_2 << endl << endl;
    }

    free(READ_1);
    free(READ_2);
    free(Qvalue_1);
    free(Qvalue_2);

  } else {

    value = multivalue;
    for(int i=0; i<nvalues; i++) {
      string head_seq(value);
      std::size_t pos    = head_seq.find_first_of(" ");

      int PE_direction = 0;
      std::size_t pe_pos = head_seq.find_first_of("_");
      if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
      if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

      string seq(head_seq.substr(pos+1,data->range).c_str() );
      string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

      if(PE_direction==1) {
        data->outFile << seq.c_str()     << " --- " << head_seq.substr(0,pos).c_str() << " " << PE_direction << endl;
        num_sp1++;
      }

      value += valuebytes[i];
    }

    value = multivalue;
    for(int i=0; i<nvalues; i++) {
      string head_seq(value);
      std::size_t pos = head_seq.find_first_of(" ");

      int PE_direction = 0;
      std::size_t pe_pos = head_seq.find_first_of("_");
      if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
      if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

      string seq(head_seq.substr(pos+1,data->range).c_str() );
      string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

      if(PE_direction==2) {
        data->outFile << seq.c_str()     << " --- " << head_seq.substr(0,pos).c_str() << " " << PE_direction << endl;
        num_sp2++;
      }

      value += valuebytes[i];
    }

    data->outFile << endl;
    data->outFile << "ID-noConsensus::: chr:" << LinkID.chr1 << " " << LinkID.loc1 << " " << LinkID.loc2 << " SIZE: " << nvalues << " "  << num_sp1 << " " << num_sp2 << endl << endl;

 }

  free(check_error);
  free(check_error_1);
  free(check_error_2);
  free(loc_consensus_1);
  if(!overlap) free(loc_consensus_2);
  free(num_consensus1);
  free(num_consensus2);
 
  END_BLOCK_LOOP

}

void DecomposeError_NGS_PCR(int *Error, string csequence, int *cseq_loc, int cseq_len, int num, int *READ_1, int *READ_2, int *Quality_1, int *Quality_2, int qThreshold)
{
   for(int i=0; i<num*2; i++) Error[i] = 0;

   int *CSEQ = (int *) malloc( sizeof(int) * cseq_len );
   for(int i=0; i<cseq_len; i++) {
	int intBase = get_int_from_base( csequence.substr(0,cseq_len).c_str()[i] );
	CSEQ[i] =  intBase + 1;
   }

   for(int i=0; i<num; i++) {
      for(int j=0; j<cseq_len; j++) {

        if(cseq_loc[j] == 2) {
	
	   if( (CSEQ[j] != READ_1[i*cseq_len + j]) && (READ_1[i*cseq_len + j] > 0)) {
		if(Quality_1[i*cseq_len + j] < qThreshold) Error[i]     += 1;			// NGS error counts from Read 1
		else					   Error[num+i] += 1;			// PCR error counts from Read 1
	   }   

	   if( (CSEQ[j] != READ_2[i*cseq_len + j]) && (READ_2[i*cseq_len + j] > 0) ) {
                if(Quality_2[i*cseq_len + j] < qThreshold) Error[i]     += 1;			// NGS error counts from Read 2
                else                                       Error[num+i] += 1;			// PCR error counts from Read 2
           }

	}

      }
   }

   free(CSEQ);

}

void Cal_pcrEfficiency(int *OUT, int cseq_len, int num, string cseq, int *cseq_loc, int *READ_1, int *READ_2, int *QUA_1, int *QUA_2, int qval_threshold)
{
   OUT[0] = 0; OUT[1] = 0; OUT[2] = 0; OUT[3] = 0;

   int *CSEQ = (int *) malloc( sizeof(int) * cseq_len );
   for(int i=0; i<cseq_len; i++) CSEQ[i] =  get_int_from_base( cseq.substr(0,cseq_len).c_str()[i] ) + 1; 

   for(int i=0; i<num; i++) {
       for(int j=0; j<cseq_len; j++) { 

  	if( (cseq_loc[j] == 2) && (QUA_1[i*cseq_len + j] > qval_threshold) && (CSEQ[j] != READ_1[i*cseq_len + j]) ) { READ_1[i*cseq_len + j] = 1; OUT[0] += 1; }
	else			        		                                                            { READ_1[i*cseq_len + j] = 0; }

        if( (cseq_loc[j] == 2) && (QUA_2[i*cseq_len + j] > qval_threshold) && (CSEQ[j] != READ_2[i*cseq_len + j]) ) { READ_2[i*cseq_len + j] = 1; OUT[0] += 1; }
        else                                                                                                        { READ_2[i*cseq_len + j] = 0; }

	}
    } 

   for(int i=0; i<(num-1); i++) 
	for(int j=i+1; j<num; j++) {
	   for(int k=0; k<cseq_len; k++) {
		if( READ_1[i*cseq_len + k] != READ_1[j*cseq_len + k] ) OUT[1] += 1;	
		if( READ_2[i*cseq_len + k] != READ_2[j*cseq_len + k] ) OUT[1] += 1;
	   }
	}

   free(CSEQ);

}


void Get_DirectionStrand(string head_seq, int *PE_direction, int *Strand, string ref_seq, int data_range)
{
  std::size_t pe_pos = head_seq.find_first_of("_");
  if( head_seq.compare(pe_pos+1,1,"1") == 0 ) *PE_direction = 1;
  if( head_seq.compare(pe_pos+1,1,"2") == 0 ) *PE_direction = 2;

  StripedSmithWaterman::Aligner aligner;
  StripedSmithWaterman::Filter filter;
  StripedSmithWaterman::Alignment alignment_1;
  StripedSmithWaterman::Alignment alignment_2;

  std::size_t pos = head_seq.find_first_of(" ");
  string seq( head_seq.substr(pos+1,data_range).c_str() );
  string rev_seq = revcomp( head_seq.substr(pos+1,data_range) );

  alignment_1.Clear();
  aligner.Align(seq.c_str(),     ref_seq.c_str(), ref_seq.length(), filter, &alignment_1);
  alignment_2.Clear();
  aligner.Align(rev_seq.c_str(), ref_seq.c_str(), ref_seq.length(), filter, &alignment_2);

  if( alignment_1.sw_score > alignment_2.sw_score ) *Strand = 1;
  else                                              *Strand = 2;
}


bool check_alignment(StripedSmithWaterman::Alignment alignment, int len_seq, int len_ref)
{
       if( alignment.cigar.size() <= 0 ) return false;

       int32_t *bam_cigar = (int32_t *) malloc( sizeof(int32_t)*3 );

       for(size_t j = 0; j < alignment.cigar.size(); j++)  {
	    convert_cigar2bam(alignment.cigar[j], bam_cigar);
            if((int)bam_cigar[1] < 1)  return false;
	
	    switch ((int)bam_cigar[0]) {
		case 0:
			break;
		case 1:
			break;
		case 2:
			break;
		case 3:
			return false;
		case 4:
			break;
		case 5:
			return false;
		case 6:
			return false;
		case 7:
			break;
		case 8:
			break;
		default:
			return false;
	    }
	
       }

/*
       if( ((int)alignment.query_begin < 0) || ((int)alignment.query_begin >= len_seq ) ) return false;
       if( ((int)alignment.ref_begin < 0)   || ((int)alignment.ref_begin >= len_ref) ) return false;

       int match = 0;
       for(size_t j = 0; j < alignment.cigar.size(); j++)  {

         convert_cigar2bam(alignment.cigar[j], bam_cigar);
         if( (bam_cigar[0] == 0) || (bam_cigar[0] == 7) || (bam_cigar[0] == 8) ) {
	    		match += (int)bam_cigar[1];	
	 }
       }
       if(match < (len_seq-2)) return false;

       int sp     = (int)alignment.query_begin;
       int sp_loc = (int)alignment.ref_begin;
       for(size_t j = 0; j < alignment.cigar.size(); j++)  {
         convert_cigar2bam(alignment.cigar[j], bam_cigar);

	 if((int)bam_cigar[1] <= 0 ) return false;

         if( (bam_cigar[0] == 0) || (bam_cigar[0] == 7) || (bam_cigar[0] == 8) ) {

                for(int k=0; k<(int)bam_cigar[1]; k++) {
                        if( !( ((sp + k    )>=0) && ((sp + k)     < len_seq) ) ) return false;
			if( !( ((sp_loc + k)>=0) && ((sp_loc + k) < len_seq) ) ) return false;
		}

		sp     += (int)bam_cigar[1];
                sp_loc += (int)bam_cigar[1];

         } else if( bam_cigar[0] == 2 )  {
                sp_loc += (int)bam_cigar[1];
	 } else if( bam_cigar[0] == 1) {
                sp     += (int)bam_cigar[1];
         }

       }

       if(bam_cigar[0] == 4) {
          for(int k=0; k<(int)bam_cigar[1]; k++) {
                if( !( ((sp + k)     >=0) && ((sp + k)     < len_seq) ) ) return false;
		if( !( ((sp_loc + k) >=0) && ((sp_loc + k) < len_seq) ) ) return false;
	 }
       }
*/

       free(bam_cigar);
       return true;

}

void get_consensus_withBound(StripedSmithWaterman::Alignment alignment, string seq, int *num_consensus, int len_seq, int len_ref)
{
       int32_t *bam_cigar = (int32_t *) malloc( sizeof(int32_t)*3 );

       int sp     = (int)alignment.query_begin;
       int sp_loc = (int)alignment.ref_begin;

/*
       for(size_t j = 0; j < alignment.cigar.size(); j++)  {
         convert_cigar2bam(alignment.cigar[j], bam_cigar);

         if( (bam_cigar[0] == 0) || (bam_cigar[0] == 7) || (bam_cigar[0] == 8) ) {

                for(int k=0; k<(int)bam_cigar[1]; k++) 
			if( !((sp_loc + k)>=0) && ((sp_loc + k) < len_ref) ) return false;

                sp     += (int)bam_cigar[1];
                sp_loc += (int)bam_cigar[1];

         } else if( bam_cigar[0] == 2 )  {
                sp_loc += (int)bam_cigar[1];
         } else if( bam_cigar[0] == 1) {
                sp     += (int)bam_cigar[1];
         }

       }

       if(bam_cigar[0] == 4) {
          for(int k=0; k<(int)bam_cigar[1]; k++) 
		if( !((sp_loc + k)>=0) && ((sp_loc + k) < len_ref) ) return false;
       }
*/

       // Alignment of input sequence

       if( (alignment.ref_begin - alignment.query_begin) >= 0 ) {
             if(alignment.query_begin > 0) {
                    for(int j=0; j<(int)alignment.query_begin; j++) {
                       int intBase = get_int_from_base( seq.substr(0,(int)alignment.query_begin).c_str()[j] );
                       if((intBase>=0) && (intBase < 4)) num_consensus[ ((int)(alignment.ref_begin - alignment.query_begin) + j)*4 + intBase ]++;
                    }
             }
       } else {
          int ss = (int)(alignment.query_begin - alignment.ref_begin);
          for(int j=0; j<(int)alignment.ref_begin; j++) {
                int intBase = get_int_from_base( seq.substr(ss,alignment.ref_begin).c_str()[j] );
                if((intBase>=0) && (intBase < 4)) num_consensus[ j*4 + intBase ]++;
          }
       }

       sp     = (int)alignment.query_begin;
       sp_loc = (int)alignment.ref_begin;
       for(size_t j = 0; j < alignment.cigar.size(); j++)  {
         convert_cigar2bam(alignment.cigar[j], bam_cigar);

         if( (bam_cigar[0] == 0) || (bam_cigar[0] == 7) || (bam_cigar[0] == 8) ) {

                for(int k=0; k<(int)bam_cigar[1]; k++) {
			int intBase = get_int_from_base( seq.substr(sp,(int)(seq.length()-sp)).c_str()[k] );
                        if((intBase>=0) && (intBase < 4)) num_consensus[ (sp_loc + k)*4 + intBase ]++;
                }

                sp     += (int)bam_cigar[1];
                sp_loc += (int)bam_cigar[1];

         } else if( bam_cigar[0] == 2 )  {
                sp_loc += (int)bam_cigar[1];
         } else if( bam_cigar[0] == 1) {
                sp     += (int)bam_cigar[1];
         }

       }

       if(bam_cigar[0] == 4) {
          for(int k=0; k<(int)bam_cigar[1]; k++) {
			int intBase = get_int_from_base( seq.substr(sp,(int)(seq.length()-sp)).c_str()[k] );
                        if((intBase>=0) && (intBase < 4)) num_consensus[ (sp_loc + k)*4 + intBase ]++;
          }
       }

       free(bam_cigar);
 //      return true;
}


void get_consensus(StripedSmithWaterman::Alignment alignment, string seq, int *num_consensus)
{
       if( (alignment.ref_begin - alignment.query_begin) >= 0 ) {
             if(alignment.query_begin > 0) {
                    for(int j=0; j<(int)alignment.query_begin; j++) {
                       int intBase = get_int_from_base( seq.substr(0,(int)alignment.query_begin).c_str()[j] );
                       if((intBase>=0) && (intBase < 4)) num_consensus[ ((int)(alignment.ref_begin - alignment.query_begin) + j)*4 + intBase ]++;
                    }
             }
       } else {
          int ss = (int)(alignment.query_begin - alignment.ref_begin);
          for(int j=0; j<(int)alignment.ref_begin; j++) {
                int intBase = get_int_from_base( seq.substr(ss,alignment.ref_begin).c_str()[j] );
                if((intBase>=0) && (intBase < 4)) num_consensus[ j*4 + intBase ]++;
          }
       }

       int32_t *bam_cigar = (int32_t *) malloc( sizeof(int32_t)*3 );
       
       int sp     = (int)alignment.query_begin;
       int sp_loc = (int)alignment.ref_begin;
       for(size_t j = 0; j < alignment.cigar.size(); j++)  {
         convert_cigar2bam(alignment.cigar[j], bam_cigar);

         if( (bam_cigar[0] == 0) || (bam_cigar[0] == 7) || (bam_cigar[0] == 8) ) {

                for(int k=0; k<(int)bam_cigar[1]; k++) {
                        int intBase = get_int_from_base( seq.substr(sp,(int)bam_cigar[1]).c_str()[k] );
                        if((intBase>=0) && (intBase < 4)) num_consensus[ (sp_loc + k)*4 + intBase ]++;
                }

                sp     += (int)bam_cigar[1];
                sp_loc += (int)bam_cigar[1];

         } else if( bam_cigar[0] == 2 )  {
                sp_loc += (int)bam_cigar[1];
         } else if( bam_cigar[0] == 1) {
                sp     += (int)bam_cigar[1];
         }

       }

       if(bam_cigar[0] == 4) {
          for(int k=0; k<(int)bam_cigar[1]; k++) {
                        int intBase = get_int_from_base( seq.substr(sp,(int)bam_cigar[1]).c_str()[k] );
                        if((intBase>=0) && (intBase < 4)) num_consensus[ (sp_loc + k)*4 + intBase ]++;
          }
       }

       free(bam_cigar);
}

int check_deletion_consensus(int *num_consensus1, int *num_consensus2, int len_consensus, int num_sp1, int num_sp2)
{
  int threshold1 = (int) floor(num_sp1 * 0.35);
  int threshold2 = (int) floor(num_sp2 * 0.35);
  int num_deletion = 0;

  for(int i=0; i<len_consensus; i++) {

      int num1 = 0;
      int num2 = 0;

      for(int j=0; j<4; j++) {
        num1 += num_consensus1[i*4+j];
        num2 += num_consensus2[i*4+j];
      }

      if( (num1 <= threshold1) && (num2 <= threshold2) ) num_deletion++;

  }

  return (num_deletion);
}

int check_deletion_consensus_single(int *num_consensus, int len_consensus, int num_sp)
{
  int threshold = (int) floor(num_sp * 0.35);
  int num_deletion = 0;
  for(int i=0; i<len_consensus; i++) {
      int num = 0;
      for(int j=0; j<4; j++) num += num_consensus[i*4+j];
      if( num <= threshold ) num_deletion++;
  }
  return (num_deletion);

}

string check_consensus_sequence(const char *ref_seq, int *check_error, int *num_consensus1, int *num_consensus2, int len_consensus, int num_sp1, int num_sp2, int * loc_consensus)
{
  char *consen_seq = (char *) malloc( sizeof(char)*len_consensus );

  int threshold = num_sp1-1;
  int *buffer = (int *) malloc( sizeof(int) * 5 );

  for(int i=0; i<len_consensus; i++) {

      int num = 0;
      for(int j=0; j<4; j++)  buffer[j] = 0;
      for(int j=0; j<4; j++) {
        if(num_consensus1[i*4+j] > 0) buffer[j] += num_consensus1[i*4+j]; 
        if(num_consensus2[i*4+j] > 0) buffer[j] += num_consensus2[i*4+j]; 
        num += buffer[j];
      }

      int ind = -1;
      int max = 0;
      for(int j=0; j<4; j++) {
        if(buffer[j] > max) { ind = j; max = buffer[j]; }
      }

      if(ind >= 0) consen_seq[i] = get_base_from_int(ind);
      else         consen_seq[i] = 'N';

      if( ((num-max)>0) && (max > 0) && (num > 0) && (ind >= 0) ) {
                check_error[2] += (num - buffer[ind]);
                check_error[1]++; loc_consensus[i] = 2;
      }

  }

  string csequence;
  csequence.assign( consen_seq, len_consensus );
  free(consen_seq);
  free(buffer);
  return ( csequence.substr(0,len_consensus).c_str() );
}


string check_consensus_sequence_iDES(const char *ref_seq, int *check_error, int *num_consensus1, int *num_consensus2, int *numCSEN,int len_consensus, int num_sp1, int num_sp2, int * loc_consensus)
{
  char *consen_seq = (char *) malloc( sizeof(char)*len_consensus );

  int threshold = num_sp1-1;
  int *buffer = (int *) malloc( sizeof(int) * 5 );

  for(int i=0; i<len_consensus; i++) {

      int num = 0;
      for(int j=0; j<4; j++)  buffer[j] = 0;
      for(int j=0; j<4; j++) {
        if(num_consensus1[i*4+j] > 0) buffer[j] += num_consensus1[i*4+j];  
        if(num_consensus2[i*4+j] > 0) buffer[j] += num_consensus2[i*4+j];

	numCSEN[i*4+j] = num_consensus1[i*4+j] + num_consensus2[i*4+j];

        num += buffer[j];
      }

      int ind = -1;
      int max = 0;
      for(int j=0; j<4; j++) {
        if(buffer[j] > max) { ind = j; max = buffer[j]; }
      }

      if(ind >= 0) consen_seq[i] = get_base_from_int(ind);
      else         consen_seq[i] = 'N';

      if( ((num-max)>0) && (max > 0) && (num > 0) && (ind >= 0) ) {
                check_error[2] += (num - buffer[ind]);
                check_error[1]++; loc_consensus[i] = 2;
      }

  }

  string csequence( consen_seq );
  free(consen_seq);
  free(buffer);
  return ( csequence.substr(0,len_consensus).c_str() );
}


string check_consensus_seq_single(const char *ref_seq, int *check_error, int *num_consensus, int len_consensus, int num_sp, int *loc_consensus)
{
  char *consen_seq = (char *) malloc( sizeof(char)*len_consensus );

  int threshold = 1;

  for(int i=0; i<len_consensus; i++) {

      int ind = 0;
      int max = num_consensus[i*4];

      for(int j=1; j<4; j++) {
        if(num_consensus[i*4+j] > max) { ind = j; max = num_consensus[i*4+j]; }
      }

      int num = 0;
      for(int j=0; j<4; j++) num += num_consensus[i*4+j];

      if(num > 0) {
        consen_seq[i] = get_base_from_int(ind);
        if( (max < num) && ((num - num_consensus[i*4+ind])>0) ) {
                check_error[1] += (num - num_consensus[i*4+ind]);
                check_error[0]++; loc_consensus[i] = 1;
        }
      } else {
        consen_seq[i] = ref_seq[i];
      }

  }
  string csequence( consen_seq );
  free(consen_seq);
  return ( csequence.substr(0,len_consensus).c_str() );
}

void extract_read_quality(StripedSmithWaterman::Alignment alignment, string seq, string quality, int *READ, int *Qvalue, int idRead, int csen_len, int numRead)
{
       int sloc = idRead * csen_len;

       if( (alignment.ref_begin - alignment.query_begin) >= 0 ) {
             if(alignment.query_begin > 0) {

                for(int j=0; j<(int)alignment.query_begin; j++) {
                     int intBase = get_int_from_base( seq.substr(0,(int)alignment.query_begin).c_str()[j] );
                     int intQvalue = get_Qscore( quality.substr(0,(int)alignment.query_begin).c_str()[j] );
                     if(intBase < 4) {
                            READ[   sloc + (int)(alignment.ref_begin - alignment.query_begin) + j ] = intBase + 1;
                            Qvalue[ sloc + (int)(alignment.ref_begin - alignment.query_begin) + j ] = intQvalue;
                     }
                }
             }

        } else {
          int ss = (int)(alignment.query_begin - alignment.ref_begin);

          for(int j=0; j<(int)alignment.ref_begin; j++) {
                int intBase = get_int_from_base( seq.substr(ss,alignment.ref_begin).c_str()[j] );
                int intQvalue = get_Qscore( quality.substr(ss,alignment.ref_begin).c_str()[j] );
                if(intBase < 4) {
                        READ[   sloc + j ] = intBase + 1;
                        Qvalue[ sloc + j ] = intQvalue;
                }
          }

       }

       int32_t *bam_cigar = (int32_t *) malloc( sizeof(int32_t)*3 );

       int sp     = (int)alignment.query_begin;
       int sp_loc = (int)alignment.ref_begin;
       for(size_t j = 0; j < alignment.cigar.size(); j++)  {
         convert_cigar2bam(alignment.cigar[j], bam_cigar);

         if( (bam_cigar[0] == 0) || (bam_cigar[0] == 7) || (bam_cigar[0] == 8) ) {

                for(int k=0; k<(int)bam_cigar[1]; k++) {
                        int intBase = get_int_from_base( seq.substr(sp,(int)bam_cigar[1]).c_str()[k] );
                        int intQvalue = get_Qscore( quality.substr(sp,(int)bam_cigar[1]).c_str()[k] );
                        if(intBase < 4) {
                             if( (sloc + sp_loc + k) <= (csen_len*numRead) ) {
                                READ[   sloc + sp_loc + k ] = intBase + 1;
                                Qvalue[ sloc + sp_loc + k ] = intQvalue;
                             }
                        }
                }

                sp     += (int)bam_cigar[1];
                sp_loc += (int)bam_cigar[1];

         } else if( bam_cigar[0] == 2 )  {
                sp_loc += (int)bam_cigar[1];
         } else if( bam_cigar[0] == 1) {

//                for(int k=0; k<(int)bam_cigar[1]; k++) {
//                        int intBase = get_int_from_base( seq.substr(sp,(int)bam_cigar[1]).c_str()[k] );
//                        int intQvalue = get_Qscore( quality.substr(sp,(int)bam_cigar[1]).c_str()[k] );
//                        if(intBase < 4) {
//                           if( (sloc + sp_loc + k) <= (csen_len*numRead) ) {
//                                READ[   sloc + sp_loc + k ] = intBase + 1;
//                                Qvalue[ sloc + sp_loc + k ] = intQvalue;
//                           }
//                        }
//                }

                sp     += (int)bam_cigar[1];
//                sp_loc += (int)bam_cigar[1];
         }

       }

       if(bam_cigar[0] == 4) {

          for(int k=0; k<(int)bam_cigar[1]; k++) {
                        int intBase = get_int_from_base( seq.substr(sp,(int)bam_cigar[1]).c_str()[k] );
                        int intQvalue = get_Qscore( quality.substr(sp,(int)bam_cigar[1]).c_str()[k] );
                        if(intBase < 4) {
                             if( (sloc + sp_loc + k) <= (csen_len*numRead) ) {
                                READ[   sloc + sp_loc + k ] = intBase + 1;
                                Qvalue[ sloc + sp_loc + k ] = intQvalue;
                             }
                        }
          }
       }

       free(bam_cigar);

}

void print_reads(std::ofstream &outFile, StripedSmithWaterman::Alignment alignment, string seq, string quality, int *READ, int *Qvalue, int idRead, int csen_len, int numRead)
{

//if (!((seq.c_str() != NULL) && (seq.c_str()[0] == '\0'))) {
// if((alignment.cigar.size() > 0) && (!seq.empty())) {

       std::stringstream sOUT;
       int sloc = idRead * csen_len;

       if( (alignment.ref_begin - alignment.query_begin) >= 0 ) {
             for(int j=0; j<abs( (int)(alignment.ref_begin-alignment.query_begin) ); j++) outFile << " ";
                 //if( (int)alignment.query_begin>0 ) outFile << seq.substr(0,(int)alignment.query_begin).c_str();
		if( (int)alignment.query_begin>0 )  sOUT << seq.substr(0,(int)alignment.query_begin).c_str();

                   //   for(int j=0; j<(int)alignment.query_begin; j++) {
                   //       int intBase = get_int_from_base( seq.substr(0,(int)alignment.query_begin).c_str()[j] );
		//	  int intQvalue = get_Qscore( quality.substr(0,(int)alignment.query_begin).c_str()[j] );
                //          if(intBase < 4) {
		//		READ[   sloc + (int)(alignment.ref_begin - alignment.query_begin) + j ] = intBase + 1;	
		//		Qvalue[ sloc + (int)(alignment.ref_begin - alignment.query_begin) + j ] = intQvalue; 
		//	  } 
                //      }

        } else {
          int ss = (int)(alignment.query_begin - alignment.ref_begin);
          if((int)alignment.ref_begin > 0) {
		//outFile << seq.substr(ss,(int)alignment.ref_begin).c_str();
		sOUT << seq.substr(ss,(int)alignment.ref_begin).c_str();

         // for(int j=0; j<(int)alignment.ref_begin; j++) {
         //       int intBase = get_int_from_base( seq.substr(ss,alignment.ref_begin).c_str()[j] );
//		int intQvalue = get_Qscore( quality.substr(ss,alignment.ref_begin).c_str()[j] );
 //               if(intBase < 4) {
//			READ[   sloc + j ] = intBase + 1;
//			Qvalue[ sloc + j ] = intQvalue;
//		}
//          }
 
	 }
      }

       int32_t *bam_cigar = (int32_t *) malloc( sizeof(int32_t)*3 );

       int sp     = (int)alignment.query_begin;
       int sp_loc = (int)alignment.ref_begin;
       for(size_t j = 0; j < alignment.cigar.size(); j++)  {
         convert_cigar2bam(alignment.cigar[j], bam_cigar);

         if( (bam_cigar[0] == 0) || (bam_cigar[0] == 7) || (bam_cigar[0] == 8) ) {
         //        outFile << seq.substr(sp,(int)bam_cigar[1]).c_str();
		  sOUT << seq.substr(sp,(int)bam_cigar[1]).c_str();		

      //          for(int k=0; k<(int)bam_cigar[1]; k++) {
       //                 int intBase = get_int_from_base( seq.substr(sp,(int)bam_cigar[1]).c_str()[k] );
//			int intQvalue = get_Qscore( quality.substr(sp,(int)bam_cigar[1]).c_str()[k] );
//                        if(intBase < 4) { 
//			     if( (sloc + sp_loc + k) <= (csen_len*numRead) ) {
//				READ[   sloc + sp_loc + k ] = intBase + 1;
//				Qvalue[ sloc + sp_loc + k ] = intQvalue; 
//			     }
//			}
//                }

                sp     += (int)bam_cigar[1];
                sp_loc += (int)bam_cigar[1];

         } else if( bam_cigar[0] == 2 )  {
//                for(int k=0; k<(int)bam_cigar[1]; k++) outFile << "-";
		for(int k=0; k<(int)bam_cigar[1]; k++) sOUT << "-";
                sp_loc += (int)bam_cigar[1];
         } else if( bam_cigar[0] == 1) {

             //   for(int k=0; k<(int)bam_cigar[1]; k++) {
             //           int intBase = get_int_from_base( seq.substr(sp,(int)bam_cigar[1]).c_str()[k] );
	//		int intQvalue = get_Qscore( quality.substr(sp,(int)bam_cigar[1]).c_str()[k] );
         //               if(intBase < 4) {
	//		   if( (sloc + sp_loc + k) <= (csen_len*numRead) ) {
	//			READ[   sloc + sp_loc + k ] = intBase + 1;
	//			Qvalue[ sloc + sp_loc + k ] = intQvalue; 
	//		   }
	//		}
         //       }

                sp     += (int)bam_cigar[1];
             //   sp_loc += (int)bam_cigar[1];
         }

       }

       if(bam_cigar[0] == 4) {
//          outFile << seq.substr(sp,(int)bam_cigar[1]).c_str();
	  sOUT << seq.substr(sp,(int)bam_cigar[1]).c_str();

//          for(int k=0; k<(int)bam_cigar[1]; k++) {
//                        int intBase = get_int_from_base( seq.substr(sp,(int)bam_cigar[1]).c_str()[k] );
//			int intQvalue = get_Qscore( quality.substr(sp,(int)bam_cigar[1]).c_str()[k] );
//                        if(intBase < 4) {
//			     if( (sloc + sp_loc + k) <= (csen_len*numRead) ) {
//				READ[   sloc + sp_loc + k ] = intBase + 1;
//				Qvalue[ sloc + sp_loc + k ] = intQvalue;
//			     }
//			}
//          }
       }
 
       outFile << sOUT.str().c_str() << endl;

       free(bam_cigar);
//  }
}


//#####################################################
//       Error Cleaning 
//

void reduce_errorCorrection_reads(char *key, int keybytes, char *multivalue, int nvalues, int *valuebytes, KeyValue *kv, void *ptr)
{
  Data *data = (Data *) ptr;
  char *value;

  PairID LinkID = *(PairID *) key;

  bool overlap = false;
  int offset;
  if(LinkID.loc1 <= LinkID.loc2) offset = LinkID.loc1 + data->range - 1 - LinkID.loc2;
  else                           offset = LinkID.loc2 + data->range - 1 - LinkID.loc1;
  if( offset > (int)data->kmer_length ) overlap = true;


  string ref_sequence_1, ref_sequence_2;

  IRKE irke_1(data->kmer_length, data->MAX_RECURSION, data->MIN_SEED_ENTROPY, data->MIN_SEED_COVERAGE,
             data->min_any_entropy, data->PACMAN, data->CRAWL, data->crawl_length, data->DS);

  IRKE irke_2(data->kmer_length, data->MAX_RECURSION, data->MIN_SEED_ENTROPY, data->MIN_SEED_COVERAGE,
             data->min_any_entropy, data->PACMAN, data->CRAWL, data->crawl_length, data->DS);


  StripedSmithWaterman::Aligner aligner;
  StripedSmithWaterman::Filter filter;
  StripedSmithWaterman::Alignment alignment;

  uint64_t nvalues_total;
  CHECK_FOR_BLOCKS(multivalue,valuebytes,nvalues,nvalues_total)
  BEGIN_BLOCK_LOOP(multivalue,valuebytes,nvalues)

if(data->On_Clean) {

    if(data->On_Assemble) {

        value = multivalue;
        for(int i=0; i<nvalues; i++) {
           string head_seq(value);
           std::size_t pos = head_seq.find_first_of(" ");

           int PE_direction = 0;
           std::size_t pe_pos = head_seq.find_first_of("_");
           if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
           if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

           string seq(head_seq.substr(pos+1,data->range).c_str() );
           string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

           int nKmer = data->range - data->kmer_length + 1;
           for(int j=0; j<nKmer; j++) {

           string seq_kmer = seq.substr(j, data->kmer_length);

              if( contains_non_gatc(seq_kmer) ) {
                 uint64_t kmer_val = kmer_to_intval(seq_kmer);
                 uint64_t rkmer_val = revcomp_val(kmer_val, data->kmer_length);

                 if(overlap) {
                   irke_1.add_kmer(kmer_val , 1);
                   irke_1.add_kmer(rkmer_val , 1);
                 } else if(PE_direction == 1) {
                   irke_1.add_kmer(kmer_val , 1);
                   irke_1.add_kmer(rkmer_val , 1);
                 } else {
                   irke_2.add_kmer(kmer_val , 1);
                   irke_2.add_kmer(rkmer_val , 1);
                 }
             }

          }

          value += valuebytes[i];
       }

       irke_1.prune_some_kmers(data->min_kmer_count, data->min_any_entropy, data->prune_error_kmers, data->min_ratio_non_error);
       irke_1.populate_sorted_kmers_list();

       ref_sequence_1 = irke_1.compute_sequence_assemblies( data->MIN_CONNECTIVITY_RATIO, data->MIN_ASSEMBLY_LENGTH, data->MIN_ASSEMBLY_COVERAGE );

       if(!overlap) {
         irke_2.prune_some_kmers(data->min_kmer_count, data->min_any_entropy, data->prune_error_kmers, data->min_ratio_non_error);
         irke_2.populate_sorted_kmers_list();
         ref_sequence_2 = irke_2.compute_sequence_assemblies( data->MIN_CONNECTIVITY_RATIO, data->MIN_ASSEMBLY_LENGTH, data->MIN_ASSEMBLY_COVERAGE );
       }

    } else if(data->On_Alignment) {

        if(overlap) {
                if(LinkID.loc1 <= LinkID.loc2) ref_sequence_1 = data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc1, LinkID.loc2-LinkID.loc1+data->range-1);
                else                           ref_sequence_1 = data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc2, LinkID.loc1-LinkID.loc2+data->range-1);
        } else {
                ref_sequence_1 = data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc1, data->range);
                ref_sequence_2 = data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc2, data->range);
        }

   }

   bool check_assembly_length = true;
   if(ref_sequence_1.length() < data->range)                check_assembly_length = false;
   if(!overlap && (ref_sequence_2.length() < data->range))  check_assembly_length = false;

   if( check_assembly_length ) {

        int *check_error   = (int *) malloc(sizeof(int)*4);
        int *check_error_1 = (int *) malloc(sizeof(int)*4);
        int *check_error_2 = (int *) malloc(sizeof(int)*4);

        std::size_t  len_consen_1 = ref_sequence_1.size();
        std::size_t  len_consen_2 = 0;
        if(!overlap) len_consen_2 = ref_sequence_2.size();

        int *loc_consensus_1  = (int *) malloc( sizeof(int) * (len_consen_1+1)*2 );
        int *loc_consensus_2;
        if(!overlap) loc_consensus_2 = (int *) malloc( sizeof(int) * (len_consen_2+1)*2 );

        int *num_consensus1 = (int *) malloc( sizeof(int) * (len_consen_1+1) * 4 * 2 );
        int *num_consensus2;

        if(overlap) num_consensus2 = (int *) malloc( sizeof(int) * (len_consen_1+1) * 4 * 2 );
        else        num_consensus2 = (int *) malloc( sizeof(int) * (len_consen_2+1) * 4 * 2 );

        for(int i=0; i<len_consen_1*2; i++) loc_consensus_1[i] = 0;
        if(!overlap)
           for(int i=0; i<len_consen_2*2; i++) loc_consensus_2[i] = 0;

        for(int i=0; i<len_consen_1*4*2; i++) num_consensus1[i] = 0;
        if(overlap) {
                for(int i=0; i<len_consen_1*4*2; i++) num_consensus2[i] = 0;
        } else {
                for(int i=0; i<len_consen_2*4*2; i++) num_consensus2[i] = 0;
        }

        string csequence_1, csequence_2;
        int num_sp1 = 0;
        int num_sp2 = 0;

        value = multivalue;
        for(int i=0; i<nvalues; i++) {
           string head_seq(value);
           std::size_t pos = head_seq.find_first_of(" ");

           int PE_direction = 0;
           std::size_t pe_pos = head_seq.find_first_of("_");
           if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
           if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

           int Strand = 0;
           if(overlap) { Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_1, data->range); }
           else  {
                if(PE_direction == 1) Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_1, data->range);
                else                  Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_2, data->range);
           }

           string seq     = head_seq.substr(pos+1,data->range).c_str();
           string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

           if(PE_direction == 1) {
                alignment.Clear();

                if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_1.c_str(), len_consen_1, filter, &alignment);
                else            aligner.Align(rev_seq.c_str(), ref_sequence_1.c_str(), len_consen_1, filter, &alignment);

                if(Strand == 1) get_consensus(alignment, seq,     num_consensus1);
                else            get_consensus(alignment, rev_seq, num_consensus1);

                num_sp1++;
           }

           if(PE_direction == 2) {

                alignment.Clear();
                if(overlap) {
                   if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_1.c_str(), len_consen_1, filter, &alignment);
                   else            aligner.Align(rev_seq.c_str(), ref_sequence_1.c_str(), len_consen_1, filter, &alignment);
                } else {
                   aligner.Align(rev_seq.c_str(), ref_sequence_2.c_str(), len_consen_2, filter, &alignment);
                   if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_2.c_str(), len_consen_2, filter, &alignment);
                   else            aligner.Align(rev_seq.c_str(), ref_sequence_2.c_str(), len_consen_2, filter, &alignment);
                }

                if(Strand == 1) get_consensus(alignment, seq,     num_consensus2);
                else            get_consensus(alignment, rev_seq, num_consensus2);

                num_sp2++;
           }

           value += valuebytes[i];
        }


        int num_deletion_1 = 0;
        int num_deletion_2 = 0;
        if(data->On_Alignment) {

                if(overlap) {
                        num_deletion_1 = check_deletion_consensus(num_consensus1, num_consensus2, len_consen_1, num_sp1, num_sp2);
                } else {
                        num_deletion_1 = check_deletion_consensus_single(num_consensus1, len_consen_1, num_sp1);
                        num_deletion_2 = check_deletion_consensus_single(num_consensus2, len_consen_2, num_sp2);
                }

                if( overlap && (num_deletion_1 > 0) ) {

                        if(LinkID.loc1 <= LinkID.loc2) ref_sequence_1.assign( data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc1, LinkID.loc2-LinkID.loc1+data->range-1 + num_deletion_1) );
                        else                           ref_sequence_1.assign( data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc2, LinkID.loc1-LinkID.loc2+data->range-1 + num_deletion_1) );
                        len_consen_1 = ref_sequence_1.size();

                        free(loc_consensus_1);
                        free(num_consensus1);

                        loc_consensus_1 = (int *) malloc( sizeof(int) * (len_consen_1+1) * 2 );
                        num_consensus1  = (int *) malloc( sizeof(int) * (len_consen_1+1) * 4 * 2 );

                        for(int i=0; i<(len_consen_1+1)*2; i++)   loc_consensus_1[i] = 0;
                        for(int i=0; i<(len_consen_1+1)*4*2; i++) num_consensus1[i] = 0;

                        value = multivalue;
                        for(int i=0; i<nvalues; i++) {
                                string head_seq(value);
                                std::size_t pos    = head_seq.find_first_of(" ");

                                int PE_direction = 0;
                                std::size_t pe_pos = head_seq.find_first_of("_");
                                if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
                                if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

                                int Strand = 0;
                                Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_1, data->range);

                                string seq( head_seq.substr(pos+1,data->range).c_str() );
                                string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

                                alignment.Clear();
                                if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_1.c_str(), len_consen_1, filter, &alignment);
                                else            aligner.Align(rev_seq.c_str(), ref_sequence_1.c_str(), len_consen_1, filter, &alignment);


                                if(PE_direction == 1) {
                                        if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus1);
                                        else            get_consensus(alignment, rev_seq.c_str(), num_consensus1);
                                }

                                if(PE_direction == 2) {
                                        if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus2);
                                        else            get_consensus(alignment, rev_seq.c_str(), num_consensus2);
                                }

                                value += valuebytes[i];
                        }
                }


                if( !overlap && (num_deletion_1 > 0) ) {

                        ref_sequence_1.assign( data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc1, data->range + num_deletion_1) );
                        len_consen_1 = ref_sequence_1.size();

                        free(loc_consensus_1);
                        free(num_consensus1);
                        loc_consensus_1 = (int *) malloc( sizeof(int) * (len_consen_1+1)*2 );
                        num_consensus1  = (int *) malloc( sizeof(int) * (len_consen_1+1) * 4 * 2 );

                        for(int i=0; i<len_consen_1*2; i++)   loc_consensus_1[i] = 0;
                        for(int i=0; i<len_consen_1*4*2; i++) num_consensus1[i] = 0;

                        value = multivalue;
                        for(int i=0; i<nvalues; i++) {
                                string head_seq(value);
                                std::size_t pos    = head_seq.find_first_of(" ");

                                int PE_direction = 0;
                                std::size_t pe_pos = head_seq.find_first_of("_");
                                if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
                                if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

                           if(PE_direction == 1) {
                                int Strand = 0;
                                Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_1, data->range);

                                string seq( head_seq.substr(pos+1,data->range).c_str() );
                                string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

                                alignment.Clear();
                                if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_1.c_str(), len_consen_1, filter, &alignment);
                                else            aligner.Align(rev_seq.c_str(), ref_sequence_1.c_str(), len_consen_1, filter, &alignment);

                                if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus1);
                                else            get_consensus(alignment, rev_seq.c_str(), num_consensus1);
                           }

                                value += valuebytes[i];
                        }
                }


                if( !overlap && (num_deletion_2 > 0) ) {

                        ref_sequence_2.assign( data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc2, data->range + num_deletion_2) );
                        len_consen_2 = ref_sequence_2.size();

                        free(loc_consensus_2);
                        free(num_consensus2);
                        loc_consensus_2 = (int *) malloc( sizeof(int) * (len_consen_2+1)*2 );
                        num_consensus2  = (int *) malloc( sizeof(int) * (len_consen_2+1) * 4 * 2 );

                        for(int i=0; i<len_consen_2*2; i++)   loc_consensus_2[i] = 0;
                        for(int i=0; i<len_consen_2*4*2; i++) num_consensus2[i] = 0;

                        value = multivalue;
                        for(int i=0; i<nvalues; i++) {
                                string head_seq(value);
                                std::size_t pos    = head_seq.find_first_of(" ");

                                int PE_direction = 0;
                                std::size_t pe_pos = head_seq.find_first_of("_");
                                if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
                                if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

                           if(PE_direction == 2) {
                                int Strand = 0;
                                Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_2, data->range);

                                string seq( head_seq.substr(pos+1,data->range).c_str() );
                                string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

                                alignment.Clear();

                                if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence_2.c_str(), len_consen_2, filter, &alignment);
                                else            aligner.Align(rev_seq.c_str(), ref_sequence_2.c_str(), len_consen_2, filter, &alignment);

                                if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus2);
                                else            get_consensus(alignment, rev_seq.c_str(), num_consensus2);
                           }

                                value += valuebytes[i];
                        }
                }

	}


        if( (num_sp1 >= 3) && (num_sp2 >= 3) ) {

                for(int k=0; k<3; k++) { check_error[k]= 0; check_error_1[k]= 0; check_error_2[k]= 0; }
                if(overlap) { csequence_1 = check_consensus_sequence( ref_sequence_1.c_str(), check_error, num_consensus1, num_consensus2, len_consen_1, num_sp1, num_sp2, loc_consensus_1); }
                else        {
                        csequence_1 = check_consensus_seq_single( ref_sequence_1.c_str(), check_error_1, num_consensus1, len_consen_1, num_sp1, loc_consensus_1);
                        csequence_2 = check_consensus_seq_single( ref_sequence_2.c_str(), check_error_2, num_consensus2, len_consen_2, num_sp2, loc_consensus_2);
                }

                bool check_consensus_length = true;
                if(csequence_1.length() < data->range)                check_consensus_length = false;
                if(!overlap && (csequence_2.length() < data->range))  check_consensus_length = false;

                float error_rate;
                if(overlap)  error_rate = 100 * ((float) check_error[2]) / ((float) ((num_sp1+num_sp2) * data->range));
                else         error_rate = 100 * ((float) (check_error_1[1] + check_error_2[1])) / ((float)((num_sp1+num_sp2) * data->range));
                if (error_rate > data->error_rate) check_consensus_length = false;

                if(check_consensus_length) {

                        vector<string> outName_1;
                        vector<string> outName_2;
                        map<string,int> outHeader_1;
                        map<string,int> outHeader_2;

                        map<string,string> headInfo_1;
                        map<string,string> headInfo_2;

                        map<string,string> outReads_1;
                        map<string,string> outReads_2;

			map<string,string> outQuality_1;
                        map<string,string> outQuality_2;

                        value = multivalue;
                        for(int i=0; i<nvalues; i++) {
                                string head_seq(value);
                                std::size_t pos    = head_seq.find_first_of(" ");
                                std::size_t pe_pos = head_seq.find_first_of("_");

                                int PE_direction = 0;

                                if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
                                if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

                                int Strand = 0;
                                if(overlap)                   Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_1, data->range);
                                else  {
                                        if(PE_direction == 1) Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_1, data->range);
                                        else                  Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence_2, data->range);
                                }

                                string seq     = head_seq.substr(pos+1,data->range).c_str();
                                string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

				string quality;
				if(data->ftype) {
					std::size_t qos    = head_seq.find_first_of("@");
					quality.assign( head_seq.substr(qos+1,data->range).c_str(), data->range );
				}

                                int str_len;

                                if(overlap) {

                                        if( PE_direction==1 ) {

					   if(outHeader_1.count(head_seq.substr(0,pe_pos)) <= 0) {
                                           	alignment.Clear();
                                           	if(Strand == 1) aligner.Align(seq.c_str(),     csequence_1.substr(0,len_consen_1).c_str(),len_consen_1, filter, &alignment);
                                           	else            aligner.Align(rev_seq.c_str(), csequence_1.substr(0,len_consen_1).c_str(),len_consen_1, filter, &alignment);
                                           	str_len = data->range;
                                           	string clean_read1 = get_cleanRead(csequence_1.substr(0,len_consen_1).c_str(),alignment, seq.c_str(), &str_len);
                                           	if(Strand != 1)  clean_read1 = revcomp( clean_read1.substr(0,str_len) );

						if( clean_read1.length() >= (data->range-5) ) {
                                                  outName_1.push_back( head_seq.substr(0,pe_pos) );
                                                  headInfo_1[head_seq.substr(0,pe_pos)] = head_seq.substr(pe_pos+1,pos-pe_pos-1);
                                                  outReads_1[head_seq.substr(0,pe_pos)] = clean_read1.substr(0,str_len);
						  if(data->ftype) outQuality_1[head_seq.substr(0,pe_pos)] = quality.substr(0,clean_read1.length());

                                                  outHeader_1[head_seq.substr(0,pe_pos)] = 1;
						}
                                           }

                                        } else if( PE_direction==2 ) {

					   if(outHeader_2.count(head_seq.substr(0,pe_pos)) <= 0) {
                                           	alignment.Clear();
                                           	if(Strand == 1) aligner.Align(seq.c_str(),     csequence_1.substr(0,len_consen_1).c_str(),len_consen_1, filter, &alignment);
                                           	else            aligner.Align(rev_seq.c_str(), csequence_1.substr(0,len_consen_1).c_str(),len_consen_1, filter, &alignment);
                                           	str_len = data->range;
                                           	string clean_read2 = get_cleanRead(csequence_1.substr(0,len_consen_1).c_str(),alignment, seq.c_str(), &str_len);
                                           	if(Strand != 1)  clean_read2 = revcomp( clean_read2.substr(0,str_len) );

					        if( clean_read2.length() >= (data->range-5) ) {
                                                  outName_2.push_back( head_seq.substr(0,pe_pos) );
                                                  headInfo_2[head_seq.substr(0,pe_pos)] = head_seq.substr(pe_pos+1,pos-pe_pos-1);
                                                  outReads_2[head_seq.substr(0,pe_pos)] = clean_read2.substr(0,str_len);
						  if(data->ftype) outQuality_2[head_seq.substr(0,pe_pos)] = quality.substr(0,clean_read2.length());

                                                  outHeader_2[head_seq.substr(0,pe_pos)] = 1;
						}
                                           }

                                        }

                                } else {

                                        if( PE_direction==1 ) {

					    if(outHeader_1.count(head_seq.substr(0,pe_pos)) <= 0) {
                                           	alignment.Clear();
                                           	if(Strand == 1) aligner.Align(seq.c_str(),     csequence_1.substr(0,len_consen_1).c_str(),len_consen_1, filter, &alignment);
                                           	else            aligner.Align(rev_seq.c_str(), csequence_1.substr(0,len_consen_1).c_str(),len_consen_1, filter, &alignment);

                                           	str_len = data->range;
                                           	string clean_read1 = get_cleanRead(csequence_1.substr(0,len_consen_1).c_str(),alignment, seq.c_str(), &str_len);
                                           	if(Strand != 1)  clean_read1 = revcomp( clean_read1.substr(0,str_len) );

						if( clean_read1.length() >= (data->range-5) ) {
                                                  outName_1.push_back( head_seq.substr(0,pe_pos) );
                                                  headInfo_1[head_seq.substr(0,pe_pos)] = head_seq.substr(pe_pos+1,pos-pe_pos-1);
                                                  outReads_1[head_seq.substr(0,pe_pos)] = clean_read1.substr(0,str_len);
						  if(data->ftype) outQuality_1[head_seq.substr(0,pe_pos)] = quality.substr(0,clean_read1.length());

                                                  outHeader_1[head_seq.substr(0,pe_pos)] = 1;
						}
                                           }

                                        } else if( PE_direction==2 ) {

					   if(outHeader_2.count(head_seq.substr(0,pe_pos)) <= 0) {
                                                alignment.Clear();
                                           	if(Strand == 1) aligner.Align(seq.c_str(),     csequence_2.substr(0,len_consen_2).c_str(),len_consen_2, filter, &alignment);
                                           	else            aligner.Align(rev_seq.c_str(), csequence_2.substr(0,len_consen_2).c_str(),len_consen_2, filter, &alignment);

                                           	str_len = data->range;
                                           	string clean_read2 = get_cleanRead(csequence_2.substr(0,len_consen_2).c_str(),alignment, seq.c_str(), &str_len);
                                           	if(Strand != 1)  clean_read2 = revcomp( clean_read2.substr(0,str_len) );

						if( clean_read2.length() >= (data->range-5) ) {
                                                  outName_2.push_back( head_seq.substr(0,pe_pos) );
                                                  headInfo_2[head_seq.substr(0,pe_pos)] = head_seq.substr(pe_pos+1,pos-pe_pos-1);
                                                  outReads_2[head_seq.substr(0,pe_pos)] = clean_read2.substr(0,str_len);
						  if(data->ftype) outQuality_2[head_seq.substr(0,pe_pos)] = quality.substr(0,clean_read2.length());

                                                  outHeader_2[head_seq.substr(0,pe_pos)] = 1;
						}
                                           }

                                        }

				}

                                value += valuebytes[i];
			}

                       if( (outName_1.size() == outName_2.size()) && (outName_1.size()>0) && (outName_2.size()>0) ) {
                        for(int i=0; i<outName_1.size(); i++) {
                                if( (outHeader_1.count(outName_1.at(i)) > 0) && (outHeader_2.count(outName_1.at(i)) > 0) ) {

				    if(data->ftype) {
					data->outFile_R1 << "@" << outName_1.at(i).c_str() << " " << headInfo_1[outName_1.at(i)].c_str() << endl;
                                        data->outFile_R1 << outReads_1[outName_1.at(i)].c_str() << endl << "+" << endl;
					data->outFile_R1 << outQuality_1[outName_1.at(i)].c_str() << endl;

                                        data->outFile_R2 << "@" << outName_1.at(i).c_str() << " " << headInfo_2[outName_1.at(i)].c_str() << endl;
                                        data->outFile_R2 << outReads_2[outName_1.at(i)].c_str() << endl << "+" << endl;
					data->outFile_R2 << outQuality_2[outName_1.at(i)].c_str() << endl;

				    } else {
                                        data->outFile_R1 << ">" << outName_1.at(i).c_str() << " " << headInfo_1[outName_1.at(i)].c_str() << endl;
                                        data->outFile_R1 << outReads_1[outName_1.at(i)].c_str() << endl;

                                        data->outFile_R2 << ">" << outName_1.at(i).c_str() << " " << headInfo_2[outName_1.at(i)].c_str() << endl;
                                        data->outFile_R2 << outReads_2[outName_1.at(i)].c_str() << endl;
				   }

                                }
                        }
                      }

                } else if(data->On_smallCluster) {
                        print_unCleaned_reads(multivalue, nvalues, valuebytes, data->range, data->outFile_R1, data->outFile_R2, data->ftype);
                }

        } else if(data->On_smallCluster) {
                print_unCleaned_reads(multivalue, nvalues, valuebytes, data->range, data->outFile_R1, data->outFile_R2, data->ftype);
        }

        free(check_error);
        free(check_error_1);
        free(check_error_2);
        free(loc_consensus_1);
        if(!overlap) free(loc_consensus_2);
        free(num_consensus1);
        free(num_consensus2);

   } else if(data->On_smallCluster) {
        print_unCleaned_reads(multivalue, nvalues, valuebytes, data->range, data->outFile_R1, data->outFile_R2, data->ftype);
   }


} else {
     print_unCleaned_reads(multivalue, nvalues, valuebytes, data->range, data->outFile_R1, data->outFile_R2, data->ftype);
}
  

  END_BLOCK_LOOP

}

string get_cleanRead_FQ(const char *consen_seq, StripedSmithWaterman::Alignment alignment, string seq, string quality, int *len, int *numCSEN, int len_csen, float error_ratio)
{

  char *cleanRead = (char *) malloc( *len * sizeof(char) );
  char *cleanQuality = (char *) malloc( *len * sizeof(char) );
  int tlen = 0;

   if( (alignment.ref_begin - alignment.query_begin) >= 0 ) {

      tlen += (int)alignment.query_begin;
      for(int j=0; j<(int)alignment.query_begin; j++) {
	int cloc = (int)(alignment.ref_begin - alignment.query_begin)+j;

//        int intBase_csen = get_int_from_base( consen_seq[cloc+j]);
	int intBase_query = get_int_from_base( seq.at(j) );

//        if(intBase_csen == intBase_query) cleanRead[j]    = consen_seq[cloc+j];
//	else {

//	     int tnum = 0;
//	     for(int l=0; l<4; l++) tnum += numCSEN[cloc*4 + l];

//	     if(tnum > 0) {
//		float ratio = numCSEN[cloc*4+intBase_query] / numCSEN[cloc*4+intBase_csen];
//		float ratio = numCSEN[cloc*4+intBase_query] / tnum;
//		if(ratio < error_ratio) cleanRead[j] = consen_seq[cloc+j];
//		else			cleanRead[j] = seq.at(j);
//	     } else cleanRead[j] = seq.at(j);

//	}

	if( (intBase_query>=0) && (intBase_query<=3) ) {
	  if(numCSEN[cloc*4 + intBase_query] == 1) cleanRead[j] = seq.at(j);
	  else				           cleanRead[j] = consen_seq[cloc+j];
	} else					   cleanRead[j] = consen_seq[cloc+j];	

	cleanQuality[j] = quality.at(j);
      }

   } else {

      int ss = (int)(alignment.query_begin - alignment.ref_begin);
      tlen += ss;
      for(int j=0; j<ss; j++) { 
	cleanRead[j]    = seq.substr(0,ss).c_str()[j];
	cleanQuality[j] = quality.substr(0,ss).c_str()[j];
      }

      tlen += (int)alignment.ref_begin;
      for(int j=0; j<(int)alignment.ref_begin; j++) { 

//	int intBase_csen = get_int_from_base( consen_seq[j]);
        int intBase_query = get_int_from_base( seq.at(ss+j) );	

//	if(intBase_csen == intBase_query) cleanRead[ss+j]    = consen_seq[j];
//	else {

//             int tnum = 0;
//             for(int l=0; l<4; l++) tnum += numCSEN[j*4 + l];
	    
//	    if(tnum > 0) {
//		float ratio = numCSEN[j*4+intBase_query] / numCSEN[j*4+intBase_csen];
//		float ratio = numCSEN[j*4+intBase_query] / tnum;
//                if(ratio < error_ratio) cleanRead[ss+j] = consen_seq[j];
//                else                    cleanRead[ss+j] = seq.substr(0,ss).at(j);	
//	    } else cleanRead[ss+j] = seq.substr(0,ss).at(j);

//	}

	if((intBase_query >= 0) && (intBase_query<=3)) {
	  if(numCSEN[j*4 + intBase_query] == 1) cleanRead[ss+j] = seq.at(ss+j);
	  else					cleanRead[ss+j] = consen_seq[j];
	} else 					cleanRead[ss+j] = consen_seq[j];

        cleanQuality[ss+j] = quality.at(ss+j); 
      }

   }

   int32_t *bam_cigar = (int32_t *) malloc( sizeof(int32_t)*3 );

   int sp     = (int)alignment.query_begin;
   int sp_loc = (int)alignment.ref_begin;
   for(size_t j = 0; j < alignment.cigar.size(); j++)  {
         convert_cigar2bam(alignment.cigar[j], bam_cigar);
         if( (bam_cigar[0] == 0) || (bam_cigar[0] == 7) || (bam_cigar[0] == 8) ) {
       //     tlen += (int)bam_cigar[1];
      	     int ct = 0; 
	     for(int k=0; k<(int)bam_cigar[1]; k++) {

//		int intBase_csen  = get_int_from_base( consen_seq[sp_loc + k]);
        	int intBase_query = get_int_from_base( seq.at(sp+k) );	

//		if(intBase_csen == intBase_query) cleanRead[sp + k] = consen_seq[sp_loc + k];
//		else {

//             	    int tnum = 0;
//             	    for(int l=0; l<4; l++) tnum += numCSEN[(sp_loc+k)*4 + l];

//		    if(tnum > 0) {
//			float ratio = numCSEN[(sp_loc+k)*4+intBase_query] / numCSEN[(sp_loc+k)*4+intBase_csen];
//			float ratio = numCSEN[(sp_loc+k)*4+intBase_query] / tnum;

//                	if(ratio < error_ratio) cleanRead[sp+k] = consen_seq[sp_loc + k];
//                	else                    cleanRead[sp+k] = seq.at(sp+k);
//		    } else cleanRead[sp+k] = seq.at(sp+k);

//		}

		if( ((sp+k)<seq.length()) && ((sp_loc)<len_csen) ) {

		  if((intBase_query >= 0) && (intBase_query<=3)) {
		    if(numCSEN[(sp_loc+k)*4 + intBase_query] == 1) cleanRead[sp+k] = seq.at(sp+k);
		    else					   cleanRead[sp+k] = consen_seq[sp_loc + k];
		  } else					   cleanRead[sp+k] = consen_seq[sp_loc + k];

		  cleanQuality[sp+k] = quality.at(sp+k);
		  ct += 1;
		}
	    }

	    tlen += ct;
            sp     += (int)bam_cigar[1];
            sp_loc += (int)bam_cigar[1];

         } else if( bam_cigar[0] == 2 )  {
                sp_loc += (int)bam_cigar[1];
         } else if( bam_cigar[0] == 1) {

//		tlen += (int)bam_cigar[1];	
		int ct = 0;
		for(int k=0; k<(int)bam_cigar[1]; k++) {
		     if( (sp+k)<seq.length() ) {
			cleanRead[sp + k]   = seq.at(sp+k);
			cleanQuality[sp +k] = quality.at(sp+k);
			ct += 1;
		     }
		}
                sp += (int)bam_cigar[1];
		tlen += ct;

        }

   }

   if(bam_cigar[0] == 4) {
//      tlen += (int)bam_cigar[1];
      int ct = 0;
      for(int k=0; k<(int)bam_cigar[1]; k++) {
	   if( ((sp+k) < seq.length()) && ((sp_loc+k) < len_csen) ) {

		 int intBase_query = get_int_from_base( seq.at(sp+k) );
	       
		 if((intBase_query >= 0) && (intBase_query<=3)) { 
		   if(numCSEN[(sp_loc+k)*4 + intBase_query] == 1) cleanRead[sp + k] = seq.at(sp+k); 
                   else			                          cleanRead[sp + k] = consen_seq[sp_loc + k];
		 } else						  cleanRead[sp + k] = consen_seq[sp_loc + k];


//		 cleanRead[sp + k]   = seq.at(sp+k);
		 cleanQuality[sp +k] = quality.at(sp+k);
		 ct += 1;
	   }
      }
      tlen += ct;
   }

   free(bam_cigar);

   char *tmp_array = (char *) malloc( sizeof(char)*(tlen + tlen + 1) );

   memcpy(tmp_array, cleanRead, tlen);
   free(cleanRead);

   tmp_array[tlen]=' ';

   for(int i=0; i<tlen; i++) tmp_array[tlen+1+i] = cleanQuality[i];
   free(cleanQuality);

   string out_read( tmp_array );
   free(tmp_array);

   *len = tlen;
   return( out_read.substr(0,tlen + tlen + 1).c_str() );
}


string get_cleanRead(const char *consen_seq, StripedSmithWaterman::Alignment alignment, string seq, int *len)
{
   char *cleanRead = (char *) malloc( *len * sizeof(char) );
   int tlen = 0;

   if( (alignment.ref_begin - alignment.query_begin) >= 0 ) {

      tlen += (int)alignment.query_begin;
      for(int j=0; j<(int)alignment.query_begin; j++)
        cleanRead[j] = consen_seq[(int)(alignment.ref_begin - alignment.query_begin)+j];

   } else {

       int ss = (int)(alignment.query_begin - alignment.ref_begin);
       tlen += ss;
       for(int j=0; j<ss; j++) cleanRead[j] = seq.substr(0,ss).c_str()[j];
       tlen += (int)alignment.ref_begin;
       for(int j=0; j<(int)alignment.ref_begin; j++) cleanRead[ss+j] = consen_seq[j];

   }

   int32_t *bam_cigar = (int32_t *) malloc( sizeof(int32_t)*3 );

   int sp     = (int)alignment.query_begin;
   int sp_loc = (int)alignment.ref_begin;
   for(size_t j = 0; j < alignment.cigar.size(); j++)  {
         convert_cigar2bam(alignment.cigar[j], bam_cigar);
         if( (bam_cigar[0] == 0) || (bam_cigar[0] == 7) || (bam_cigar[0] == 8) ) {
            tlen += (int)bam_cigar[1];
            for(int k=0; k<(int)bam_cigar[1]; k++) cleanRead[sp + k] = consen_seq[sp_loc + k];
            sp     += (int)bam_cigar[1];
            sp_loc += (int)bam_cigar[1];

         } else if( bam_cigar[0] == 2 )  {
                sp_loc += (int)bam_cigar[1];
         }

   }

   if(bam_cigar[0] == 4) {
      tlen += (int)bam_cigar[1];
      for(int k=0; k<(int)bam_cigar[1]; k++)
                 cleanRead[sp + k] = consen_seq[sp_loc + k];
   }

   char *tmp_array = (char *) malloc( sizeof(char)*tlen );

   memcpy(tmp_array, cleanRead, tlen);

   string out_read( tmp_array );
   *len = tlen;

   free(cleanRead);
   free(tmp_array);
   free(bam_cigar);

   return( out_read.substr(0,tlen).c_str() );

}


void print_unCleaned_reads(char *multivalue, int nvalues, int *valuebytes, int data_range, std::ofstream &outFile_R1, std::ofstream &outFile_R2, bool ftype)
{

        vector<string> outName_1;
        vector<string> outName_2;
        map<string,int> outHeader_1;
        map<string,int> outHeader_2;

        map<string,string> headInfo_1;
        map<string,string> headInfo_2;

        map<string,string> outReads_1;
        map<string,string> outReads_2;

	map<string,string> outQuality_1;
        map<string,string> outQuality_2;

        char *value = multivalue;
        for(int i=0; i<nvalues; i++) {
            string head_seq(value);
            std::size_t pos = head_seq.find_first_of(" ");
            string seq( head_seq.substr(pos+1,data_range).c_str() );

	    string quality;
            if(ftype) {
            	std::size_t qos    = head_seq.find_first_of("@");
            	quality.assign( head_seq.substr(qos+1,data_range).c_str(), data_range );
            }

            std::size_t pe_pos = head_seq.find_first_of("_");
            int PE_direction = 0;
            if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
            if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

          if(PE_direction == 1) {

                if(outHeader_1.count(head_seq.substr(0,pe_pos)) <= 0) {
                             outName_1.push_back( head_seq.substr(0,pe_pos) );
                             headInfo_1[head_seq.substr(0,pe_pos)] = head_seq.substr(pe_pos+1,pos-pe_pos-1);
                             outReads_1[head_seq.substr(0,pe_pos)] = seq.substr(0,seq.length());
			     if(ftype) outQuality_1[head_seq.substr(0,pe_pos)] = quality.substr(0,seq.length());

                             outHeader_1[head_seq.substr(0,pe_pos)] = 1;
                }

          } else if(PE_direction == 2) {

                if(outHeader_2.count(head_seq.substr(0,pe_pos)) <= 0) {
                             outName_2.push_back( head_seq.substr(0,pe_pos) );
                             headInfo_2[head_seq.substr(0,pe_pos)] = head_seq.substr(pe_pos+1,pos-pe_pos-1);
                             outReads_2[head_seq.substr(0,pe_pos)] = seq.substr(0,seq.length());
			     if(ftype) outQuality_2[head_seq.substr(0,pe_pos)] = quality.substr(0,seq.length());

                             outHeader_2[head_seq.substr(0,pe_pos)] = 1;
                }

            }

            value += valuebytes[i];
        }

        if( (outName_1.size() == outName_2.size()) && (outName_1.size()>0) && (outName_2.size()>0) ) {
              for(int i=0; i<outName_1.size(); i++) {
                     if( (outHeader_1.count(outName_1.at(i)) > 0) && (outHeader_2.count(outName_1.at(i)) > 0) ) {
				
			     if(ftype) {
                                        outFile_R1 << "@" << outName_1.at(i).c_str() << " " << headInfo_1[outName_1.at(i)].c_str() << endl;
                                        outFile_R1 << outReads_1[outName_1.at(i)].c_str() << endl << "+" << endl;
                                        outFile_R1 << outQuality_1[outName_1.at(i)].c_str() << endl;

                                        outFile_R2 << "@" << outName_1.at(i).c_str() << " " << headInfo_2[outName_1.at(i)].c_str() << endl;
                                        outFile_R2 << outReads_2[outName_1.at(i)].c_str() << endl << "+" << endl;
                                        outFile_R2 << outQuality_2[outName_1.at(i)].c_str() << endl;

                             } else {

                             		outFile_R1 << ">" << outName_1.at(i).c_str() << " " << headInfo_1[outName_1.at(i)].c_str() << endl;
                             		outFile_R1 << outReads_1[outName_1.at(i)].c_str() << endl;

                             		outFile_R2 << ">" << outName_1.at(i).c_str() << " " << headInfo_2[outName_1.at(i)].c_str() << endl;
                             		outFile_R2 << outReads_2[outName_1.at(i)].c_str() << endl;
			     }
                     }
              }
        }


}

void reduce_base_contrast(char *key, int keybytes, char *multivalue, int nvalues, int *valuebytes, KeyValue *kv, void *ptr)
{

  Data *data = (Data *) ptr;
  char *value;

  PairID LinkID = *(PairID *) key;

  std::size_t  len_consen;

  bool overlap = false;
  int offset;
  if(LinkID.loc1 <= LinkID.loc2) offset = LinkID.loc1 + data->range - 1 - LinkID.loc2;
  else                           offset = LinkID.loc2 + data->range - 1 - LinkID.loc1;
  if( offset >= data->OVERLAP ) overlap = true;

  string ref_sequence;

  if(data->On_Alignment) {
    if(overlap) {
        if(LinkID.loc1 <= LinkID.loc2) ref_sequence = data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc1, LinkID.loc2-LinkID.loc1+data->range-1);
        else                           ref_sequence = data->reference_sequence[LinkID.chr1-1].substr(LinkID.loc2, LinkID.loc1-LinkID.loc2+data->range-1);
    }
  }

  IRKE irke(data->kmer_length, data->MAX_RECURSION, data->MIN_SEED_ENTROPY, data->MIN_SEED_COVERAGE,
            data->min_any_entropy, data->PACMAN, data->CRAWL, data->crawl_length, data->DS);

  StripedSmithWaterman::Aligner aligner;
  StripedSmithWaterman::Filter filter;
  StripedSmithWaterman::Alignment alignment;

  uint64_t nvalues_total;
  CHECK_FOR_BLOCKS(multivalue,valuebytes,nvalues,nvalues_total)
  BEGIN_BLOCK_LOOP(multivalue,valuebytes,nvalues)

if(data->On_Assemble) {

   value = multivalue;
   for(int i=0; i<nvalues; i++) {
     string head_seq(value);
     std::size_t pos = head_seq.find_first_of(" ");

     int PE_direction = 0;
     std::size_t pe_pos = head_seq.find_first_of("_");
     if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
     if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

     string seq(head_seq.substr(pos+1,data->range).c_str() );
     string rev_seq = revcomp( seq.substr(0,data->range) );

     int nKmer = data->range - data->kmer_length + 1;
     for(int j=0; j<nKmer; j++) {

        string seq_kmer = seq.substr(j, data->kmer_length);

        if( contains_non_gatc(seq_kmer) ) {
            uint64_t kmer_val = kmer_to_intval(seq_kmer);
            uint64_t rkmer_val = revcomp_val(kmer_val, data->kmer_length);

            if(overlap) {
                irke.add_kmer(kmer_val , 1);
                irke.add_kmer(rkmer_val , 1);
            }

        }

     }

     value += valuebytes[i];
   }

    irke.prune_some_kmers(data->min_kmer_count, data->min_any_entropy, data->prune_error_kmers, data->min_ratio_non_error);
    irke.populate_sorted_kmers_list();

    ref_sequence = irke.compute_sequence_assemblies( data->MIN_CONNECTIVITY_RATIO, data->MIN_ASSEMBLY_LENGTH, data->MIN_ASSEMBLY_COVERAGE );

}


  int *check_error   = (int *) malloc(sizeof(int)*4);
  len_consen = ref_sequence.size();
  int *loc_consensus  = (int *) malloc( sizeof(int) * (len_consen+1)*2 );
  int *num_consensus1 = (int *) malloc( sizeof(int) * (len_consen+1) * 4 * 2 );
  int *num_consensus2 = (int *) malloc( sizeof(int) * (len_consen+1) * 4 * 2 );

  for(int i=0; i<(len_consen+1)*2; i++) loc_consensus[i] = 0;

  for(int i=0; i<(len_consen+1)*4*2; i++) num_consensus1[i] = 0;
  for(int i=0; i<(len_consen+1)*4*2; i++) num_consensus2[i] = 0;

  string csequence;
  int num_sp1 = 0;
  int num_sp2 = 0;

  if( overlap && (len_consen >= data->range) && (nvalues >= 6) ) {

    value = multivalue;
    for(int i=0; i<nvalues; i++) {
       string head_seq(value);
       std::size_t pos    = head_seq.find_first_of(" ");

       int PE_direction = 0;
       std::size_t pe_pos = head_seq.find_first_of("_");
       if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
       if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

       string seq( head_seq.substr(pos+1,data->range).c_str() );
       string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

       if(PE_direction == 1) {
         int Strand = 0;
         Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence, data->range);

         alignment.Clear();
         if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence.c_str(), len_consen, filter, &alignment);
         else            aligner.Align(rev_seq.c_str(), ref_sequence.c_str(), len_consen, filter, &alignment);

         if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus1);
         else            get_consensus(alignment, rev_seq.c_str(), num_consensus1);

	 num_sp1++;
       }

	if(PE_direction == 2) {
         int Strand = 0;
         Get_DirectionStrand(head_seq, &PE_direction, &Strand, ref_sequence, data->range);

         alignment.Clear();
         if(Strand == 1) aligner.Align(seq.c_str(),     ref_sequence.c_str(), len_consen, filter, &alignment);
         else            aligner.Align(rev_seq.c_str(), ref_sequence.c_str(), len_consen, filter, &alignment);

         if(Strand == 1) get_consensus(alignment, seq.c_str(),     num_consensus2);
         else            get_consensus(alignment, rev_seq.c_str(), num_consensus2);

         num_sp2++;
       }


      value += valuebytes[i];
    }


if( (num_sp1 >= 3) && (num_sp2 >= 3) ) {
    

     int *base_contrast = (int *) malloc( sizeof(int) * len_consen);
     int *depth = (int *) malloc( sizeof(int) * len_consen);
     csequence = check_base_contrast(base_contrast, depth, num_consensus1, num_consensus2, len_consen, num_sp1, num_sp2, loc_consensus);

//     for(int k=0; k<len_consen; k++) {
//        if((loc_consensus[k] > 0) && (base_contrast[k] > 0)) data->outFile << base_contrast[k] << "\t" << depth[k] << "\t" << num_sp1 << "\t" << num_sp2 << endl;
//     }


    value = multivalue;
    for(int i=0; i<nvalues; i++) {
       string head_seq(value);
       std::size_t pos    = head_seq.find_first_of(" ");

       int PE_direction = 0;
       std::size_t pe_pos = head_seq.find_first_of("_");
       if( head_seq.compare(pe_pos+1,1,"1") == 0 ) PE_direction = 1;
       if( head_seq.compare(pe_pos+1,1,"2") == 0 ) PE_direction = 2;

       if( (PE_direction == 1) || (PE_direction == 2) ) {
 
         string seq( head_seq.substr(pos+1,data->range).c_str() );
         string rev_seq = revcomp( seq.substr(0,data->range).c_str() );

         string quality, rev_quality;
         if(data->ftype) {
            std::size_t qos = head_seq.find_first_of("@");
            quality.assign( head_seq.substr(qos+1,data->range).c_str(), data->range );
	    rev_quality.assign( revquality( quality.substr(0,data->range).c_str() ) );
         }

         int Strand = 0;
         Get_DirectionStrand(head_seq, &PE_direction, &Strand, csequence, data->range);

         alignment.Clear();
         if(Strand == 1) {
		aligner.Align(seq.c_str(),     csequence.c_str(), len_consen, filter, &alignment);
	//	get_error_quality(data->outFile, alignment, seq.c_str(),  quality.c_str(), loc_consensus, base_contrast, depth, num_sp1, num_sp2);
//		get_quality_counts(alignment, seq.c_str(),  quality.c_str(), loc_consensus, base_contrast, depth, num_sp1, num_sp2, data->QV_error, data->QV_nerror);
         } else {           
		aligner.Align(rev_seq.c_str(), csequence.c_str(), len_consen, filter, &alignment);
	//	get_error_quality(data->outFile, alignment, rev_seq.c_str(), rev_quality.substr(0,data->range).c_str(), loc_consensus, base_contrast, depth, num_sp1, num_sp2);
//		get_quality_counts(alignment, rev_seq.c_str(), rev_quality.substr(0,data->range).c_str(), loc_consensus, base_contrast, depth, num_sp1, num_sp2, data->QV_error, data->QV_nerror); 
         }

       }

       value += valuebytes[i];
    }

     free(base_contrast);
     free(depth);
}

  }

  free(check_error);
  free(loc_consensus);
  free(num_consensus1);
  free(num_consensus2);

  END_BLOCK_LOOP

}

string check_base_contrast(int *base_contrast, int *depth, int *num_consensus1, int *num_consensus2, int len_consensus, int num_sp1, int num_sp2, int * loc_consensus)
{
  char *consen_seq = (char *) malloc( sizeof(char)*len_consensus );

  int *buffer = (int *) malloc( sizeof(int) * 5 );

  for(int i=0; i<len_consensus; i++) { depth[i] = 0; base_contrast[i] = 0; loc_consensus[i] = 0; }
  for(int i=0; i<len_consensus; i++) {

      int num = 0;
      for(int j=0; j<4; j++)  buffer[j] = 0;
      for(int j=0; j<4; j++) {
        if(num_consensus1[i*4+j] > 0) buffer[j] += num_consensus1[i*4+j];
        if(num_consensus2[i*4+j] > 0) buffer[j] += num_consensus2[i*4+j];
        num += buffer[j];
      }

      int ind = -1;
      int max = 0;
      for(int j=0; j<4; j++) {
        if(buffer[j] > max) { ind = j; max = buffer[j]; }
      }

      if(ind >= 0) consen_seq[i] = get_base_from_int(ind);
      else         consen_seq[i] = 'N';

     if( ((num - max) > 0) && (ind > 0) ) {
        base_contrast[i] = max;
        depth[i]         = num;
        loc_consensus[i] = ind+1;
     }
  }

  string csequence( consen_seq );
  free(consen_seq);
  free(buffer);
  return ( csequence.substr(0,len_consensus).c_str() );
}

void get_quality_counts(StripedSmithWaterman::Alignment alignment, string seq, string quality, int *loc_consensus, int *base_contrast, int *depth, int num_sp1, int num_sp2, uint64_t *error_bin, uint64_t *nerror_bin)
{

   int base_loc;

   if( (alignment.ref_begin - alignment.query_begin) >= 0 ) {
        if(alignment.query_begin > 0) {
              for(int j=0; j<(int)alignment.query_begin; j++) {
                   int intBase = get_int_from_base( seq.substr(0,(int)alignment.query_begin).c_str()[j] );
                   base_loc = (int)(alignment.ref_begin - alignment.query_begin) + j;

		   if( (intBase>=0) && (intBase < 4) && (loc_consensus[base_loc] > 0) ) {
			if(intBase != (loc_consensus[base_loc]-1)) error_bin[ get_Qscore( quality.substr(0,(int)alignment.query_begin).c_str()[j] ) ]++;
			else					   nerror_bin[ get_Qscore( quality.substr(0,(int)alignment.query_begin).c_str()[j] ) ]++;

		   }

/*
                   if( (intBase>=0) && (intBase < 4) && (intBase != (loc_consensus[base_loc]-1)) && (loc_consensus[base_loc] > 0) )  
		         error_bin[ get_Qscore( quality.substr(0,(int)alignment.query_begin).c_str()[j] ) ]++; 
		   else if( base_contrast[base_loc] == depth[base_loc] )
			 nerror_bin[ get_Qscore( quality.substr(0,(int)alignment.query_begin).c_str()[j] ) ]++;
*/

              }
        }
   } else {
          int ss = (int)(alignment.query_begin - alignment.ref_begin);
          for(int j=0; j<(int)alignment.ref_begin; j++) {
                int intBase = get_int_from_base( seq.substr(ss,alignment.ref_begin).c_str()[j] );
                base_loc = j;

		if( (intBase>=0) && (intBase < 4) && (loc_consensus[base_loc] > 0) ) {
			if(intBase != (loc_consensus[base_loc]-1)) error_bin[ get_Qscore( quality.substr(ss,alignment.ref_begin).c_str()[j] ) ]++;
			else					   nerror_bin[ get_Qscore( quality.substr(ss,alignment.ref_begin).c_str()[j] ) ]++;
		}


/*
                if( (intBase>=0) && (intBase < 4) && (intBase != (loc_consensus[base_loc]-1)) && (loc_consensus[base_loc] > 0) ) 
		    error_bin[ get_Qscore( quality.substr(ss,alignment.ref_begin).c_str()[j] ) ]++;
		else if( base_contrast[base_loc] == depth[base_loc] )
		    nerror_bin[ get_Qscore( quality.substr(ss,alignment.ref_begin).c_str()[j] ) ]++;
*/      

 
	   }
   }

   int32_t *bam_cigar = (int32_t *) malloc( sizeof(int32_t)*3 );

   int sp     = (int)alignment.query_begin;
   int sp_loc = (int)alignment.ref_begin;
   for(size_t j = 0; j < alignment.cigar.size(); j++)  {
      convert_cigar2bam(alignment.cigar[j], bam_cigar);

      if( (bam_cigar[0] == 0) || (bam_cigar[0] == 7) || (bam_cigar[0] == 8) ) {

            for(int k=0; k<(int)bam_cigar[1]; k++) {
                  int intBase = get_int_from_base( seq.substr(sp,(int)bam_cigar[1]).c_str()[k] );
                  base_loc = sp_loc + k;

		if( (intBase>=0) && (intBase < 4) && (loc_consensus[base_loc] > 0) ) {
			if(intBase != (loc_consensus[base_loc]-1))  error_bin[ get_Qscore( quality.substr(sp,(int)bam_cigar[1]).c_str()[k] ) ]++;
			else					    nerror_bin[ get_Qscore( quality.substr(sp,(int)bam_cigar[1]).c_str()[k] ) ]++;

		}


/*
                  if( (intBase>=0) && (intBase < 4) && (intBase != (loc_consensus[base_loc]-1)) && (loc_consensus[base_loc] > 0) ) 
		      error_bin[ get_Qscore( quality.substr(sp,(int)bam_cigar[1]).c_str()[k] ) ]++; 
		  else if( base_contrast[base_loc] == depth[base_loc] )
		      nerror_bin[ get_Qscore( quality.substr(sp,(int)bam_cigar[1]).c_str()[k] ) ]++;
*/


             }

             sp     += (int)bam_cigar[1];
             sp_loc += (int)bam_cigar[1];

      } else if( bam_cigar[0] == 2 )  {
                sp_loc += (int)bam_cigar[1];
      } else if( bam_cigar[0] == 1) {
                sp     += (int)bam_cigar[1];
      }

   }

   free(bam_cigar);

}


void get_error_quality(std::ofstream &outFile, StripedSmithWaterman::Alignment alignment, string seq, string quality, int *loc_consensus, int *base_contrast, int *depth, int num_sp1, int num_sp2)
{
	int base_loc;

        if( (alignment.ref_begin - alignment.query_begin) >= 0 ) {
             if(alignment.query_begin > 0) {
                    for(int j=0; j<(int)alignment.query_begin; j++) {
                       int intBase = get_int_from_base( seq.substr(0,(int)alignment.query_begin).c_str()[j] );
		       base_loc = (int)(alignment.ref_begin - alignment.query_begin) + j;			

                       if( (intBase>=0) && (intBase < 4) && (intBase != (loc_consensus[base_loc]-1)) && (loc_consensus[base_loc] > 0) )  { 
		          outFile << base_contrast[base_loc] << "\t" << depth[base_loc] << "\t" << num_sp1 << "\t" << num_sp2 << "\t" << get_Qscore( quality.substr(0,(int)alignment.query_begin).c_str()[j] )  << endl;
		       }
                    }
             }
       } else {
          int ss = (int)(alignment.query_begin - alignment.ref_begin);
          for(int j=0; j<(int)alignment.ref_begin; j++) {
                int intBase = get_int_from_base( seq.substr(ss,alignment.ref_begin).c_str()[j] );
		base_loc = j;

                if( (intBase>=0) && (intBase < 4) && (intBase != (loc_consensus[base_loc]-1)) && (loc_consensus[base_loc] > 0) ) {
		    outFile << base_contrast[base_loc] << "\t" << depth[base_loc] << "\t" << num_sp1 << "\t" << num_sp2 << "\t" << get_Qscore( quality.substr(ss,alignment.ref_begin).c_str()[j] ) << endl;			
	        }
          }
       }

       int32_t *bam_cigar = (int32_t *) malloc( sizeof(int32_t)*3 );

       int sp     = (int)alignment.query_begin;
       int sp_loc = (int)alignment.ref_begin;
       for(size_t j = 0; j < alignment.cigar.size(); j++)  {
         convert_cigar2bam(alignment.cigar[j], bam_cigar);

         if( (bam_cigar[0] == 0) || (bam_cigar[0] == 7) || (bam_cigar[0] == 8) ) {

                for(int k=0; k<(int)bam_cigar[1]; k++) {
                        int intBase = get_int_from_base( seq.substr(sp,(int)bam_cigar[1]).c_str()[k] );
			base_loc = sp_loc + k;

                        if( (intBase>=0) && (intBase < 4) && (intBase != (loc_consensus[base_loc]-1)) && (loc_consensus[base_loc] > 0) ) {
			    outFile << base_contrast[base_loc] << "\t" << depth[base_loc] << "\t" << num_sp1 << "\t" << num_sp2 << "\t" << get_Qscore( quality.substr(sp,(int)bam_cigar[1]).c_str()[k] ) << endl;
			}
                }

                sp     += (int)bam_cigar[1];
                sp_loc += (int)bam_cigar[1];

         } else if( bam_cigar[0] == 2 )  {
                sp_loc += (int)bam_cigar[1];
         } else if( bam_cigar[0] == 1) {
                sp     += (int)bam_cigar[1];
         }

       }

//       if(bam_cigar[0] == 4) {
//          for(int k=0; k<(int)bam_cigar[1]; k++) {
//                        int intBase = get_int_from_base( seq.substr(sp,(int)bam_cigar[1]).c_str()[k] );
//			base_loc = sp_loc + k;

//                        if( (intBase>=0) && (intBase < 4) && (intBase != (loc_consensus[base_loc]-1)) && (loc_consensus[base_loc] > 0) ) 
//			   outFile << base_contrast[base_loc] << "\t" << depth[base_loc] << "\t" << num_sp1 << "\t" << num_sp2 << "\t" << get_Qscore( quality.substr(sp,(int)bam_cigar[1]).c_str()[k] ) << endl;
//          }
//       }

       free(bam_cigar);
}

